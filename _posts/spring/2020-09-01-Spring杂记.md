---
layout:     post
title:      Spring 杂记
subtitle:   Spring 杂记
date:       2020-09-01
author:     Eagle Cool
header-img: img/post-bg-ios9-web.jpg
catalog: 	true
tags:       Spring
---
# 控制反转（IOC）

系统依赖对象的获得被反转了，由自身实现反转为外部注入。控制反转的实现方式有**依赖注入**和**依赖查找**。
Spring Framework 主要采用**依赖注入**来实现控制反转，但其也实现了*依赖查找*。

# Spring IoC Container

* BeanFactory 提供了一种高级的配置机制，能够管理任何类型的对象。
* ApplicationContext 相较于 BeanFactory 提供了更多的功能，如下：
    * 易于集成 Spring’s AOP
    * 国际化的 Message resource 处理
    * 事件发布
    * 应用层特定的上下文，例如 Web 应用程序中使用的 WebApplicationContext

## BeanFactory

![](https://s1.ax1x.com/2020/09/18/w4Kr5T.png)

### BeanFactory

访问 Spring bean 容器的根接口。

bean 容器的基础客户端视图；ListableBeanFactory and ConfigurableBeanFactory 接口
是可用于特定目的接口。

这个接口被持有许多 bean definitions 的对象实现，每个 bean definition 都被一个唯一的 
beanName 标识。依赖于 bean definition，BeanFactory 将返回一个包含对象的独立实例
(Prototype 设计模式)，或者一个单独的共享实例(一种优于单例设计模式的选择，其中实例是 
Scope 内的单例实例)。返回实例的类型取决于 BeanFactory 的配置：API是相同的。从 
Spring 2.0 开始，更多的 Scope 可以使用在具体的 application context 中(如 Web 
环境的 "request" and "session")。

这种方法的要点是 BeanFactory 是 application components 的注册中心，配置中心(例如，
不再需要单个对象读取属性文件)。

注意，通过使用 setters or constructors 依赖注入 "push" 配置的形式配置对象，而不是
通过 BeanFactory lookup "pull" 配置的形式配置对象。Spring's 依赖注入功能是使用 
BeanFactory 和它的子接口实现的。

通常 BeanFactory 从一个配置源(如，XML)中加载 bean definitions，然后使用 
org.springframework.beans package 去配置 beans。然而，一个实现可以直接在 Java 
代码中返回它根据需要创建的 Java 对象。bean definitions 的存储方式没有任何限制: 
LDAP, RDBMS, XML, properties file 等。鼓励实现支持 bean 之间的引用。

与 ListableBeanFactory 的方法不同，BeanFactory 如果是 HierarchicalBeanFactory 
，那么它的操作总是校验 parent BeanFactory。如果一个 bean 在当前 BeanFactory 中没有
被发现，直接 parent BeanFactory 将被访问。当前 BeanFactory 中的 bean 应该覆盖任何
parent BeanFactory 中同名的 bean。

BeanFactory 的实现应该尽可能的支持标准的 bean 生命周期接口。

initialization methods: 
1. BeanNameAware's setBeanName
2. BeanClassLoaderAware's setBeanClassLoader
3. BeanFactoryAware's setBeanFactory
4. EnvironmentAware's setEnvironment
5. EmbeddedValueResolverAware's setEmbeddedValueResolver
6. ResourceLoaderAware's setResourceLoader (only applicable when running in an application context)
7. ApplicationEventPublisherAware's setApplicationEventPublisher (only applicable when running in an application context)
8. MessageSourceAware's setMessageSource (only applicable when running in an application context)
9. ApplicationContextAware's setApplicationContext (only applicable when running in an application context)
10. ServletContextAware's setServletContext (only applicable when running in a web application context)
11. postProcessBeforeInitialization methods of BeanPostProcessors
12. InitializingBean's afterPropertiesSet
13. a custom init-method definition
14. postProcessAfterInitialization methods of BeanPostProcessors

shutdown methods:
1. postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors
2. DisposableBean's destroy
3. a custom destroy-method definition

### HierarchicalBeanFactory

BeanFactory 的子接口，是可以成为 hierarchy 的一部分。可以在 
ConfigurableBeanFactory 接口中找到 setParentBeanFactory 方法，该方法允许以可配置
的方式设置 parent。

### ListableBeanFactory

ListableBeanFactory 可以列举出所有 bean 实例，而不是根据客户端的请求逐个尝试按名称查找
bean。预加载所有 bean definitions 的 BeanFactory 实现(如，基于 XML 的 BeanFactory)，
可以实现这个接口。

如果当前 BeanFactory 是 HierarchicalBeanFactory，则返回值将不考虑任何 BeanFactory 层次结构，
而仅与当前 BeanFactory 中定义的 bean 有关。使用 BeanFactoryUtils 帮助类去考虑 ancestor Factory
中的 bean。

该接口中的方法将仅遵守当前 BeanFactory 中的 bean definitions。它们将忽略任何通过其它手段注册的 
singleton beans，如 ConfigurableBeanFactory's registerSingleton 方法；但是
getBeanNamesForType and getBeansOfType 会检查手动注册的 singleton beans。当然，
BeanFactory#getBean 方法确实也允许透明访问此类的特殊 Bean。但是，在典型情况下，无论如何，
所有 bean 都将由外部 bean definitions 来定义，因此大多数应用程序不必担心这种区别。

注意: 除了 getBeanDefinitionCount 和 containsBeanDefinition 之外，此接口中的方法并非设计
用于频繁调用。实施可能很慢。

### AutowireCapableBeanFactory

具有 autowiring 能力的 BeanFactory，前提是它们希望为现有 bean 实例公开此功能。 

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。

其他框架的集成代码可以利用此接口来 wire 和 populate Spring 无法控制生命周期的现有 bean 实例。
例如: WebWork Actions and Tapestry Page objects。

请注意，此接口不是由 ApplicationContext facades 实现的，因为应用程序代码几乎从未使用过此接口。
也就是说，它也可以从 application context 中获得，可以通过 
ApplicationContext#getAutowireCapableBeanFactory 方法进行访问。

您还可以实现 BeanFactoryAware 接口，该接口即使在 ApplicationContext 中运行时也公开内部 
BeanFactory，以访问 AutowireCapableBeanFactory: 只需将传入的 BeanFactory 强制转换为 
AutowireCapableBeanFactory。

### AliasRegistry

别名注册表，用于管理别名的公共接口；作为`BeanDefinitionRegistry`的父接口。

### BeanDefinitionRegistry

`BeanDefinition`注册表，用于注册诸如`RootBeanDefinition`和`ChildBeanDefinition`之类的实例。
通常由内部使用AbstractBeanDefinition层次结构的BeanFactory实现。

这仅仅是一个 Spring's bean factory 包中的接口，用于封装`BeanDefinition`的注册。
标准BeanFactory接口仅覆盖对完全配置的工厂实例的访问。

Spring's BeanDefinition 的读取者希望能够处理这个接口的实现。
Spring 核心中已知的实现者是 DefaultListableBeanFactory 和 GenericApplicationContext。

### SingletonBeanRegistry

为共享 bean 实例定义注册表的接口。以统一的方式公开它们的单例管理工具。ConfigurableBeanFactory 
实现了此接口。

### ConfigurableBeanFactory

可配置的 BeanFactory 接口。

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。此扩展接口仅用于允许在框架内部进行即插即用，并允许对 BeanFactory 配置方法的
特殊访问。

### ConfigurableListableBeanFactory

提供了用于分析和修改 bean definitions 以及 pre-instantiate 单例的工具。

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。此扩展接口仅用于允许在框架内部进行即插即用，并允许对 BeanFactory 配置方法的
特殊访问。

### SimpleAliasRegistry

AliasRegistry 的简单实现。

* Map\<String, String\> aliasMap: alias --\> beanName

### DefaultSingletonBeanRegistry

共享 bean 实例的泛化注册表。允许注册 singleton 实例，该注册表的所有调用者都能通过 bean name 获取
共享 bean 实例。

支持 DisposableBean 实例注册。在注册表关闭时，执行 destroy 方法。可以注册 Bean 之间的依赖关系以
强制执行适当的关闭顺序。

此类主要用作 BeanFactory 实现的基类，从而排除了 singleton bean 实例的常见管理。

请注意，与 AbstractBeanFactory 和 DefaultListableBeanFactory 相比，此类既不假定 
bean definition 概念也不为 bean 实例指定创建过程。也可以用作委托的嵌套帮助器。

* Map\<String, Object\> singletonObjects: beanName --\> singleton bean instance
* Map\<String, ObjectFactory\<?\>\> singletonFactories: beanName --\> singleton ObjectFactory instance
* Map\<String, Object\> earlySingletonObjects: bean name --\> singletonFactories's ObjectFactory.getObject
* Set\<String\> registeredSingletons: 已经注册的 singletonObjects 和 singletonFactories 的 beanName
* Set\<String\> singletonsCurrentlyInCreation: 当前正在创建的 singleton bean instance 的 beanName
* Set\<String\> inCreationCheckExclusions: 校验是否是正在创建的 singleton bean instance 时需要排除的 beanName
* Set\<Exception\> suppressedExceptions: 抑制的异常，默认个数为 100 个(SUPPRESSED_EXCEPTIONS_LIMIT)
* boolean singletonsCurrentlyInDestruction: 指示我们当前是否在destroySingletons中的标志。
* Map\<String, Object\> disposableBeans: beanName --\> disposable bean instance
* Map\<String, Set\<String\>\> containedBeanMap: beanName --\> 其包含的 bean 的 beanName
* Map\<String, Set\<String\>\> dependentBeanMap: beanName --\> 依赖其的 bean 的 beanName
* Map\<String, Set\<String\>\> dependenciesForBeanMap: beanName --\> 其依赖的 bean 的 beanName

### FactoryBeanRegistrySupport

支持 FactoryBean 实例的注册。

* Map\<String, Object\> factoryBeanObjectCache: FactoryBean name --\> FactoryBean.getObject

### AbstractBeanFactory

BeanFactory 的抽象基类，提供了 ConfigurableBeanFactory SPI 的完整能力。不假定可列出的bean工厂: 
因此也可以用作 BeanFactory 实现的基类，该实现从某些后端资源获取 bean definitions。(其中 
bean definitions 访问是一项昂贵的操作)。

该类提供一个 singleton 缓存，通过它的的基类 DefaultSingletonBeanRegistry，singleton/prototype 判定，
FactoryBean 处理，别名，bean definition 合并 child bean definitions，bean 销毁(DisposableBean, 
自定义 destroy 方法)。此外，它可以通过实现 HierarchicalBeanFactory 管理 BeanFactory 的 hierarchy 结构，
在未知 bean 的情况下委托给 parent BeanFactory。

子类实现的主要模板方法: getBeanDefinition(String) 和 createBean(String, RootBeanDefinition, Object[])，
使用给定的 beanName 检索 bean definition。默认实现在 DefaultListableBeanFactory 和 
AbstractAutowireCapableBeanFactory 中。

* BeanFactory parentBeanFactory: parent BeanFactory
* ClassLoader beanClassLoader: 解析 bean class name 使用的 ClassLoader
* ClassLoader tempClassLoader: 临时解析 bean class name 使用的 ClassLoader，一般在 load-time weaver 模式下使用
* boolean cacheBeanMetadata: 是否缓存 Bean 元数据还是在每次访问时重新获取它
* BeanExpressionResolver beanExpressionResolver: bean definition values 中的表达式解析策略
* ConversionService conversionService: Spring 用于取代 PropertyEditors 的 ConversionService
* Set\<PropertyEditorRegistrar\> propertyEditorRegistrars: 自定义的 PropertyEditorRegistrars
* Map\<Class\<?\>, Class\<? extends PropertyEditor\>\> customEditors: requiredType --\> 自定义的 PropertyEditor 
* TypeConverter typeConverter: Spring 用于覆盖默认的 PropertyEditor 机制的 TypeConverter
* List\<StringValueResolver\> embeddedValueResolvers: String 解析器，如解析注解的属性值
* List\<BeanPostProcessor\> beanPostProcessors: BeanPostProcessors
* boolean hasInstantiationAwareBeanPostProcessors: 标记是否有 InstantiationAwareBeanPostProcessors 被注册
* boolean hasDestructionAwareBeanPostProcessors: 标记是否有 DestructionAwareBeanPostProcessors 被注册
* Map\<String, Scope\> scopes: scope 的标识 String --\> 相应的 Scope
* SecurityContextProvider securityContextProvider: 当在 SecurityManager 模式下运行时的 Security context
* Map\<String, RootBeanDefinition\> mergedBeanDefinitions: beanName --\> 合并后的 RootBeanDefinition
* Set\<String\> alreadyCreated: 至少创建过一次的 bean 的 beanName
* ThreadLocal\<Object\> prototypesCurrentlyInCreation: 当前正在创建的 prototype bean

### AbstractAutowireCapableBeanFactory

实现默认 bean 创建的抽象 BeanFactory 父类，具有 RootBeanDefinition 类指定的全部功能。

提供 bean 创建(构造器解析)，属性填充，连接(包括自动连接)，初始化。处理运行时 Bean 引用，解析托管集合，
调用初始化方法等。支持通过 name 自动注入 constructors, properties，通过 type 自动注入 properties。

子类主要实现的模板方法是 resolveDependency(DependencyDescriptor, String, Set, TypeConverter)，
使用 type 自动注入。如果工厂能够搜索其 bean definitions，则通常将通过此类搜索来实现匹配的 bean。
对于其他工厂样式，可以实现简化的匹配算法。

请注意，此类不承担或实现 bean definition 注册表功能。有关 ListableBeanFactory 和 
BeanDefinitionRegistry 接口的实现，请参见 DefaultListableBeanFactory，它们分别表示该工厂的 
API 和 SPI 视图。

* InstantiationStrategy instantiationStrategy: 创建 bean 实例的策略
* ParameterNameDiscoverer parameterNameDiscoverer: 方法参数的名字的解析策略
* boolean allowCircularReferences: 是否在 bean 间自动尝试解析循环引用
* boolean allowRawInjectionDespiteWrapping: 在循环引用的情况下，是否求助于注入一个原始 bean 实例，即使注入的 bean 最终被包装了
* Set\<Class\<?\>\> ignoredDependencyTypes: 在依赖校验或自动注入时，忽略的 types
* Set\<Class\<?\>\> ignoredDependencyInterfaces: 在依赖校验或自动注入时，忽略的 interfaces
* NamedThreadLocal\<String\> currentlyCreatedBean: 当前正在创建的 bean 的 beanName，隐式的依赖登记从用户指定的 Supplier 的回调触发的 getBean 等调用的名称。
* ConcurrentMap\<String, BeanWrapper\> factoryBeanInstanceCache: FactoryBean name --\> BeanWrapper
* ConcurrentMap\<Class\<?\>, Method[]\> factoryMethodCandidateCache: factory class --\> candidate factory methods
* ConcurrentMap\<Class\<?\>, PropertyDescriptor[]\> filteredPropertyDescriptorsCache: bean Class --\> PropertyDescriptor array

### DefaultListableBeanFactory

一个基于 bean definition 元数据的成熟 BeanFactory，可以通过 post-processors 扩展。

典型的用法是在访问 bean 之前，注册所有的 bean definitions。因此，按名称查找 Bean 是在本地 bean definition 表中
进行的廉价操作，它对预解析的 bean definition 元数据对象进行操作。

注意，特定 bean definition 格式的阅读器通常是单独实现的，而不是作为 BeanFactory 的子类实现的：
例如，参见 XmlBeanDefinitionReader。

* Class\<?\> javaxInjectProviderClass: javax.inject.Provider or null
* Map\<String, Reference\<DefaultListableBeanFactory\>\> serializableFactories: serializationId --\> DefaultListableBeanFactory
* String serializationId: 用于序列化的 id
* boolean allowBeanDefinitionOverriding: 是否允许 bean definition 覆盖
* boolean allowEagerClassLoading: 是否允许早期类加载
* Comparator\<Object\> dependencyComparator: 依赖列表的比较器
* AutowireCandidateResolver autowireCandidateResolver: 用于检查 bean definition 是否为自动装配候选的 Resolver
* Map\<Class\<?\>, Object\> resolvableDependencies: dependency type --\> 自动注入值
* Map\<String, BeanDefinition\> beanDefinitionMap: beanName --\> bean definition
* Map\<String, BeanDefinitionHolder\> mergedBeanDefinitionHolders: beanName --\> 已合并的 BeanDefinitionHolder
* Map\<Class\<?\>, String[]\> allBeanNamesByType: dependency type --\> singleton and non-singleton bean names
* List\<String\> beanDefinitionNames: bean definition names
* Set\<String\> manualSingletonNames: 手动注册的 singletons 的 names
* String[] frozenBeanDefinitionNames: 冻结配置之后的 bean definition names
* boolean configurationFrozen: bean definition 元数据是否已经被冻结

## ApplicationContext

![](https://s1.ax1x.com/2020/09/21/wbL2ee.png)

### ResourceLoader

加载资源的策略。ApplicationContext 需要提供这个功能，并支持扩展 ResourcePatternResolver。

DefaultResourceLoader 是一个独立的实现，可在 ApplicationContext 外部使用，也由 
ResourceEditor 使用。

当在 ApplicationContext 中运行时，可以使用特定上下文的资源加载策略从 Strings 填充 Resource 和 
Resource array 类型的Bean属性。

### ResourcePatternResolver

将 location pattern 解析为 Resource 对象的策略接口。

PathMatchingResourcePatternResolver 是一个独立的实现，可在 ApplicationContext 外部使用，
ResourceArrayPropertyEditor 也使用它来填充 Resource array bean 属性。

可以与任何类型的 location pattern 一起使用: 输入模式必须与策略实施相匹配。该接口仅指定转换方法，
而不是特定的模式格式。

这个接口也建议一个新的 resource prefix "classpath*:" 用于匹配类路径上的所有资源。
请注意，在这种情况下，资源位置应为不带占位符的路径。JAR files 或者 classes 目录中可以包含
多个同名的文件。

### ApplicationEventPublisher

事件发布功能的封装接口。

### EnvironmentCapable

暗示组件包含和暴露一个 Environment 引用。

所有的 Spring application contexts 都是 EnvironmentCapable，并且该接口主要用于在接受 
BeanFactory 实例的框架方法中执行 instanceof 检查，以便可以与 environment 进行交互
(如果实际上是ApplicationContext实例)。

ConfigurableApplicationContext 重新定义了 getEnvironment() 方法，并且缩小了签名，
返回 ConfigurableEnvironment。结果是 Environment 对象是“只读的”，直到从 
ConfigurableApplicationContext 访问它为止，此时也可以对其进行配置。

### MessageSource

解析 messages 的策略接口，支持 messages 的参数化和国际化。

Spring 为生产提供了两种现成的实现:
* ResourceBundleMessageSource: 建立在标准 ResourceBundle 之上，共享其局限性。
* ReloadableResourceBundleMessageSource: 高度可配置的，特别是在重新加载消息定义方面。

### ApplicationContext

application 提供配置的中心接口。当 application running 时，这是一个只读的，但是它的实现类支持
重新加载。

ApplicationContext 的功能:
* 继承自 ListableBeanFactory，提供访问 application components 的方法
* 继承自 ResourceLoader，提供以通用方式加载文件资源的能力
* 继承自 ApplicationEventPublisher，提供向已注册的 listeners 发布事件的能力
* 继承自 MessageSource，提供解析 messages，支持国际化的能力
* 继承自 parent context，在后代上下文中的定义将始终优先。例如，这意味着整个 Web application 都可以使用单个 parent context，而每个 servlet 都有其自己的 child context，child context 独立于任何其他 servlet 的 child context

除了标准的 BeanFactory 生命周期功能之外，ApplicationContext 实现检测和执行 
ApplicationContextAware，ResourceLoaderAware, ApplicationEventPublisherAware,
MessageSourceAware

### Lifecycle

定义 start/stop 生命周期控制的公共接口。典型的用法是控制异步处理。**注意: 这个接口并不意味着特定的
自动启动的语义。考虑使用 SmartLifecycle 实现自动启动**。

可以由 components(定义在 Spring context 中的 Spring bean) 和 containers(Spring ApplicationContext) 实现。
Containers 将传播 start/stop 信号给所有的 components。

可以用于直接调用或通过 JMX 进行管理操作。在后一种情况下，通常将使用 
InterfaceBasedMBeanInfoAssembler 定义 MBeanExporter，从而将活动控制的组件的可见性限制为 
Lifecycle 接口。

注意: 当前 Lifecycle 接口仅支持 top-level singleton beans. 
扩展 SmartLifecycle 接口提供与 application context 的启动和关闭阶段的复杂集成。

### ConfigurableApplicationContext

SPI 接口将由大多数 application contexts 实现，提供了一些工具来配置。

配置和生命周期方法被封装为了避免它们明显的调用 ApplicationContext client code。
当前方法应该仅仅在 startup and shutdown code 中使用。

### WebApplicationContext

为 web application 提供配置的接口。当 application running 时，这是一个只读的，但是它的实现类支持重新加载。

此接口将 getServletContext() 方法添加到通用的 ApplicationContext 接口中，并定义了
root context 必须在引导过程中绑定的众所周知的 application attribute name。

web application contexts 是 hierarchical 的，每个 application 有一个 root context，
每个 servlet 有它自己的 child context。

除了标准的 application context lifecycle 能力之外，WebApplicationContext 需要检测和执行
ServletContextAware。

### ConfigurableWebApplicationContext

可配置的 web application contexts 的接口。支持 ContextLoader 和 FrameworkServlet。

在调用 refresh 方法之前，这个接口的 setters 方法应该先被调用。它们不会自行导致 context 初始化。

### AnnotationConfigRegistry

annotation 配置的 application contexts 的公共接口。

### WebServerApplicationContext

创建和管理嵌入式 WebServer 生命周期。

### ConfigurableWebServerApplicationContext

提供工具去配置 WebServerApplicationContext

### DefaultResourceLoader

ResourceLoader 的默认实现。被 ResourceEditor 使用。

如果 location value 是 URL，将返回 UrlResource。如果不是 URL 或者是以 "classpath:"
开头的 URL，将返回 ClassPathResource。

* ClassLoader classLoader: 用于加载类路径上的 Resource
* Set\<ProtocolResolver\> protocolResolvers: 协议解析器
* Map\<Class\<?\>, Map\<Resource, ?\>\> resourceCaches: 

### AbstractApplicationContext

不强制用于配置的存储类型；简单地实现通用上下文功能。使用模板方法设计模式。

应该检测其内部 BeanFactory 中定义的特殊 bean，这个类自动注册定义在 content 中的
BeanFactoryPostProcessors, BeanPostProcessors, and ApplicationListeners。

MessageSource 可能也被提供给 context。ApplicationEventMulticaster 也被提供给 context，
默认是 SimpleApplicationEventMulticaster。

通过 DefaultResourceLoader 实现资源加载。将 non-URL 路径作为 class path resources 路径对待，

* String id: context 的唯一 id
* String displayName: context 的展示名字
* ApplicationContext parent: parent context
* ConfigurableEnvironment environment: context 的 Environment
* List\<BeanFactoryPostProcessor\> beanFactoryPostProcessors: BeanFactoryPostProcessors
* long startupDate: context 的启动时间(ms)
* AtomicBoolean active: 标记当前 context 是否 active
* AtomicBoolean closed: 标记当前 context 是否 closed
* Object startupShutdownMonitor: "refresh" and "destroy" 的同步监听器
* Thread shutdownHook: JVM shutdown hook 引用
* ResourcePatternResolver resourcePatternResolver: context 的 ResourcePatternResolver
* LifecycleProcessor lifecycleProcessor: 管理 context 中的 bean 的生命周期
* MessageSource messageSource: context 的 MessageSource
* ApplicationEventMulticaster applicationEventMulticaster: 发布事件的帮助类
* Set\<ApplicationListener\<?\>\> applicationListeners: 静态指定的 listeners
* Set\<ApplicationListener\<?\>\> earlyApplicationListeners: refresh 之前注册的 listeners
* Set\<ApplicationEvent\> earlyApplicationEvents: multicaster 设置之前发布的事件

















