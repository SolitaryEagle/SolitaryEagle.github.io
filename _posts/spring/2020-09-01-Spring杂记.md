---
layout:     post
title:      Spring 杂记
subtitle:   Spring 杂记
date:       2020-09-01
author:     Eagle Cool
header-img: img/post-bg-ios9-web.jpg
catalog: 	true
tags:       Spring
---
# 控制反转（IOC）

系统依赖对象的获得被反转了，由自身实现反转为外部注入。控制反转的实现方式有**依赖注入**和**依赖查找**。
Spring Framework 主要采用**依赖注入**来实现控制反转，但其也实现了*依赖查找*。

# Spring IoC Container

* BeanFactory 提供了一种高级的配置机制，能够管理任何类型的对象。
* ApplicationContext 相较于 BeanFactory 提供了更多的功能，如下：
    * 易于集成 Spring’s AOP
    * 国际化的 Message resource 处理
    * 事件发布
    * 应用层特定的上下文，例如 Web 应用程序中使用的 WebApplicationContext

## BeanFactory

![](https://s1.ax1x.com/2020/09/18/w4Kr5T.png)

### BeanFactory

访问 Spring bean 容器的根接口。

bean 容器的基础客户端视图；ListableBeanFactory and ConfigurableBeanFactory 接口
是可用于特定目的接口。

这个接口被持有许多 bean definitions 的对象实现，每个 bean definition 都被一个唯一的 
beanName 标识。依赖于 bean definition，BeanFactory 将返回一个包含对象的独立实例
(Prototype 设计模式)，或者一个单独的共享实例(一种优于单例设计模式的选择，其中实例是 
Scope 内的单例实例)。返回实例的类型取决于 BeanFactory 的配置：API是相同的。从 
Spring 2.0 开始，更多的 Scope 可以使用在具体的 application context 中(如 Web 
环境的 "request" and "session")。

这种方法的要点是 BeanFactory 是 application components 的注册中心，配置中心(例如，
不再需要单个对象读取属性文件)。

注意，通过使用 setters or constructors 依赖注入 "push" 配置的形式配置对象，而不是
通过 BeanFactory lookup "pull" 配置的形式配置对象。Spring's 依赖注入功能是使用 
BeanFactory 和它的子接口实现的。

通常 BeanFactory 从一个配置源(如，XML)中加载 bean definitions，然后使用 
org.springframework.beans package 去配置 beans。然而，一个实现可以直接在 Java 
代码中返回它根据需要创建的 Java 对象。bean definitions 的存储方式没有任何限制: 
LDAP, RDBMS, XML, properties file 等。鼓励实现支持 bean 之间的引用。

与 ListableBeanFactory 的方法不同，BeanFactory 如果是 HierarchicalBeanFactory 
，那么它的操作总是校验 parent BeanFactory。如果一个 bean 在当前 BeanFactory 中没有
被发现，直接 parent BeanFactory 将被访问。当前 BeanFactory 中的 bean 应该覆盖任何
parent BeanFactory 中同名的 bean。

BeanFactory 的实现应该尽可能的支持标准的 bean 生命周期接口。

initialization methods: 
1. BeanNameAware's setBeanName
2. BeanClassLoaderAware's setBeanClassLoader
3. BeanFactoryAware's setBeanFactory
4. EnvironmentAware's setEnvironment
5. EmbeddedValueResolverAware's setEmbeddedValueResolver
6. ResourceLoaderAware's setResourceLoader (only applicable when running in an application context)
7. ApplicationEventPublisherAware's setApplicationEventPublisher (only applicable when running in an application context)
8. MessageSourceAware's setMessageSource (only applicable when running in an application context)
9. ApplicationContextAware's setApplicationContext (only applicable when running in an application context)
10. ServletContextAware's setServletContext (only applicable when running in a web application context)
11. postProcessBeforeInitialization methods of BeanPostProcessors
12. InitializingBean's afterPropertiesSet
13. a custom init-method definition
14. postProcessAfterInitialization methods of BeanPostProcessors

shutdown methods:
1. postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors
2. DisposableBean's destroy
3. a custom destroy-method definition

### HierarchicalBeanFactory

BeanFactory 的子接口，是可以成为 hierarchy 的一部分。可以在 
ConfigurableBeanFactory 接口中找到 setParentBeanFactory 方法，该方法允许以可配置
的方式设置 parent。

### ListableBeanFactory

ListableBeanFactory 可以列举出所有 bean 实例，而不是根据客户端的请求逐个尝试按名称查找
bean。预加载所有 bean definitions 的 BeanFactory 实现(如，基于 XML 的 BeanFactory)，
可以实现这个接口。

如果当前 BeanFactory 是 HierarchicalBeanFactory，则返回值将不考虑任何 BeanFactory 层次结构，
而仅与当前 BeanFactory 中定义的 bean 有关。使用 BeanFactoryUtils 帮助类去考虑 ancestor Factory
中的 bean。

该接口中的方法将仅遵守当前 BeanFactory 中的 bean definitions。它们将忽略任何通过其它手段注册的 
singleton beans，如 ConfigurableBeanFactory's registerSingleton 方法；但是
getBeanNamesForType and getBeansOfType 会检查手动注册的 singleton beans。当然，
BeanFactory#getBean 方法确实也允许透明访问此类的特殊 Bean。但是，在典型情况下，无论如何，
所有 bean 都将由外部 bean definitions 来定义，因此大多数应用程序不必担心这种区别。

注意: 除了 getBeanDefinitionCount 和 containsBeanDefinition 之外，此接口中的方法并非设计
用于频繁调用。实施可能很慢。

### AutowireCapableBeanFactory

具有 autowiring 能力的 BeanFactory，前提是它们希望为现有 bean 实例公开此功能。 

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。

其他框架的集成代码可以利用此接口来 wire 和 populate Spring 无法控制生命周期的现有 bean 实例。
例如: WebWork Actions and Tapestry Page objects。

请注意，此接口不是由 ApplicationContext facades 实现的，因为应用程序代码几乎从未使用过此接口。
也就是说，它也可以从 application context 中获得，可以通过 
ApplicationContext#getAutowireCapableBeanFactory 方法进行访问。

您还可以实现 BeanFactoryAware 接口，该接口即使在 ApplicationContext 中运行时也公开内部 
BeanFactory，以访问 AutowireCapableBeanFactory: 只需将传入的 BeanFactory 强制转换为 
AutowireCapableBeanFactory。

### AliasRegistry

别名注册表，用于管理别名的公共接口；作为`BeanDefinitionRegistry`的父接口。

### BeanDefinitionRegistry

`BeanDefinition`注册表，用于注册诸如`RootBeanDefinition`和`ChildBeanDefinition`之类的实例。
通常由内部使用AbstractBeanDefinition层次结构的BeanFactory实现。

这仅仅是一个 Spring's bean factory 包中的接口，用于封装`BeanDefinition`的注册。
标准BeanFactory接口仅覆盖对完全配置的工厂实例的访问。

Spring's BeanDefinition 的读取者希望能够处理这个接口的实现。
Spring 核心中已知的实现者是 DefaultListableBeanFactory 和 GenericApplicationContext。

### SingletonBeanRegistry

为共享 bean 实例定义注册表的接口。以统一的方式公开它们的单例管理工具。ConfigurableBeanFactory 
实现了此接口。

### ConfigurableBeanFactory

可配置的 BeanFactory 接口。

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。此扩展接口仅用于允许在框架内部进行即插即用，并允许对 BeanFactory 配置方法的
特殊访问。

### ConfigurableListableBeanFactory

提供了用于分析和修改 bean definitions 以及 pre-instantiate 单例的工具。

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。此扩展接口仅用于允许在框架内部进行即插即用，并允许对 BeanFactory 配置方法的
特殊访问。

### SimpleAliasRegistry

AliasRegistry 的简单实现。

* Map\<String, String\> aliasMap: alias --\> beanName

### DefaultSingletonBeanRegistry

共享 bean 实例的泛化注册表。允许注册 singleton 实例，该注册表的所有调用者都能通过 bean name 获取
共享 bean 实例。

支持 DisposableBean 实例注册。在注册表关闭时，执行 destroy 方法。可以注册 Bean 之间的依赖关系以
强制执行适当的关闭顺序。

此类主要用作 BeanFactory 实现的基类，从而排除了 singleton bean 实例的常见管理。

请注意，与 AbstractBeanFactory 和 DefaultListableBeanFactory 相比，此类既不假定 
bean definition 概念也不为 bean 实例指定创建过程。也可以用作委托的嵌套帮助器。

* Map\<String, Object\> singletonObjects: beanName --\> singleton bean instance
* Map\<String, ObjectFactory\<?\>\> singletonFactories: beanName --\> singleton ObjectFactory instance
* Map\<String, Object\> earlySingletonObjects: bean name --\> singletonFactories's ObjectFactory.getObject
* Set\<String\> registeredSingletons: 已经注册的 singletonObjects 和 singletonFactories 的 beanName
* Set\<String\> singletonsCurrentlyInCreation: 当前正在创建的 singleton bean instance 的 beanName
* Set\<String\> inCreationCheckExclusions: 校验是否是正在创建的 singleton bean instance 时需要排除的 beanName
* Set\<Exception\> suppressedExceptions: 抑制的异常，默认个数为 100 个(SUPPRESSED_EXCEPTIONS_LIMIT)
* boolean singletonsCurrentlyInDestruction: 指示我们当前是否在destroySingletons中的标志。
* Map\<String, Object\> disposableBeans: beanName --\> disposable bean instance
* Map\<String, Set\<String\>\> containedBeanMap: beanName --\> 其包含的 bean 的 beanName
* Map\<String, Set\<String\>\> dependentBeanMap: beanName --\> 依赖其的 bean 的 beanName
* Map\<String, Set\<String\>\> dependenciesForBeanMap: beanName --\> 其依赖的 bean 的 beanName

### FactoryBeanRegistrySupport

支持 FactoryBean 实例的注册。

* Map\<String, Object\> factoryBeanObjectCache: FactoryBean name --\> FactoryBean.getObject

### AbstractBeanFactory

BeanFactory 的抽象基类，提供了 ConfigurableBeanFactory SPI 的完整能力。不假定可列出的bean工厂: 
因此也可以用作 BeanFactory 实现的基类，该实现从某些后端资源获取 bean definitions。(其中 
bean definitions 访问是一项昂贵的操作)。

该类提供一个 singleton 缓存，通过它的的基类 DefaultSingletonBeanRegistry，singleton/prototype 判定，
FactoryBean 处理，别名，bean definition 合并 child bean definitions，bean 销毁(DisposableBean, 
自定义 destroy 方法)。此外，它可以通过实现 HierarchicalBeanFactory 管理 BeanFactory 的 hierarchy 结构，
在未知 bean 的情况下委托给 parent BeanFactory。

子类实现的主要模板方法: getBeanDefinition(String) 和 createBean(String, RootBeanDefinition, Object[])，
使用给定的 beanName 检索 bean definition。默认实现在 DefaultListableBeanFactory 和 
AbstractAutowireCapableBeanFactory 中。

* BeanFactory parentBeanFactory: parent BeanFactory
* ClassLoader beanClassLoader: 解析 bean class name 使用的 ClassLoader
* ClassLoader tempClassLoader: 临时解析 bean class name 使用的 ClassLoader，一般在 load-time weaver 模式下使用
* boolean cacheBeanMetadata: 是否缓存 Bean 元数据还是在每次访问时重新获取它
* BeanExpressionResolver beanExpressionResolver: bean definition values 中的表达式解析策略
* ConversionService conversionService: Spring 用于取代 PropertyEditors 的 ConversionService
* Set\<PropertyEditorRegistrar\> propertyEditorRegistrars: 自定义的 PropertyEditorRegistrars
* Map\<Class\<?\>, Class\<? extends PropertyEditor\>\> customEditors: requiredType --\> 自定义的 PropertyEditor 
* TypeConverter typeConverter: Spring 用于覆盖默认的 PropertyEditor 机制的 TypeConverter
* List\<StringValueResolver\> embeddedValueResolvers: String 解析器，如解析注解的属性值
* List\<BeanPostProcessor\> beanPostProcessors: BeanPostProcessors
* boolean hasInstantiationAwareBeanPostProcessors: 标记是否有 InstantiationAwareBeanPostProcessors 被注册
* boolean hasDestructionAwareBeanPostProcessors: 标记是否有 DestructionAwareBeanPostProcessors 被注册
* Map\<String, Scope\> scopes: scope 的标识 String --\> 相应的 Scope
* SecurityContextProvider securityContextProvider: 当在 SecurityManager 模式下运行时的 Security context
* Map\<String, RootBeanDefinition\> mergedBeanDefinitions: beanName --\> 合并后的 RootBeanDefinition
* Set\<String\> alreadyCreated: 至少创建过一次的 bean 的 beanName
* ThreadLocal\<Object\> prototypesCurrentlyInCreation: 当前正在创建的 prototype bean

### AbstractAutowireCapableBeanFactory

实现默认 bean 创建的抽象 BeanFactory 父类，具有 RootBeanDefinition 类指定的全部功能。

提供 bean 创建(构造器解析)，属性填充，连接(包括自动连接)，初始化。处理运行时 Bean 引用，解析托管集合，
调用初始化方法等。支持通过 name 自动注入 constructors, properties，通过 type 自动注入 properties。

子类主要实现的模板方法是 resolveDependency(DependencyDescriptor, String, Set, TypeConverter)，
使用 type 自动注入。如果工厂能够搜索其 bean definitions，则通常将通过此类搜索来实现匹配的 bean。
对于其他工厂样式，可以实现简化的匹配算法。

请注意，此类不承担或实现 bean definition 注册表功能。有关 ListableBeanFactory 和 
BeanDefinitionRegistry 接口的实现，请参见 DefaultListableBeanFactory，它们分别表示该工厂的 
API 和 SPI 视图。

* InstantiationStrategy instantiationStrategy: 创建 bean 实例的策略
* ParameterNameDiscoverer parameterNameDiscoverer: 方法参数的名字的解析策略
* boolean allowCircularReferences: 是否在 bean 间自动尝试解析循环引用
* boolean allowRawInjectionDespiteWrapping: 在循环引用的情况下，是否求助于注入一个原始 bean 实例，即使注入的 bean 最终被包装了
* Set\<Class\<?\>\> ignoredDependencyTypes: 在依赖校验或自动注入时，忽略的 types
* Set\<Class\<?\>\> ignoredDependencyInterfaces: 在依赖校验或自动注入时，忽略的 interfaces
* NamedThreadLocal\<String\> currentlyCreatedBean: 当前正在创建的 bean 的 beanName，隐式的依赖登记从用户指定的 Supplier 的回调触发的 getBean 等调用的名称。
* ConcurrentMap\<String, BeanWrapper\> factoryBeanInstanceCache: FactoryBean name --\> BeanWrapper
* ConcurrentMap\<Class\<?\>, Method[]\> factoryMethodCandidateCache: factory class --\> candidate factory methods
* ConcurrentMap\<Class\<?\>, PropertyDescriptor[]\> filteredPropertyDescriptorsCache: bean Class --\> PropertyDescriptor array

### DefaultListableBeanFactory

一个基于 bean definition 元数据的成熟 BeanFactory，可以通过 post-processors 扩展。

典型的用法是在访问 bean 之前，注册所有的 bean definitions。因此，按名称查找 Bean 是在本地 bean definition 表中
进行的廉价操作，它对预解析的 bean definition 元数据对象进行操作。

注意，特定 bean definition 格式的阅读器通常是单独实现的，而不是作为 BeanFactory 的子类实现的：
例如，参见 XmlBeanDefinitionReader。

* Class\<?\> javaxInjectProviderClass: javax.inject.Provider or null
* Map\<String, Reference\<DefaultListableBeanFactory\>\> serializableFactories: serializationId --\> DefaultListableBeanFactory
* String serializationId: 用于序列化的 id
* boolean allowBeanDefinitionOverriding: 是否允许 bean definition 覆盖
* boolean allowEagerClassLoading: 是否允许早期类加载
* Comparator\<Object\> dependencyComparator: 依赖列表的比较器
* AutowireCandidateResolver autowireCandidateResolver: 用于检查 bean definition 是否为自动装配候选的 Resolver
* Map\<Class\<?\>, Object\> resolvableDependencies: dependency type --\> 自动注入值
* Map\<String, BeanDefinition\> beanDefinitionMap: beanName --\> bean definition
* Map\<String, BeanDefinitionHolder\> mergedBeanDefinitionHolders: beanName --\> 已合并的 BeanDefinitionHolder
* Map\<Class\<?\>, String[]\> allBeanNamesByType: dependency type --\> singleton and non-singleton bean names
* List\<String\> beanDefinitionNames: bean definition names
* Set\<String\> manualSingletonNames: 手动注册的 singletons 的 names
* String[] frozenBeanDefinitionNames: 冻结配置之后的 bean definition names
* boolean configurationFrozen: bean definition 元数据是否已经被冻结

## ApplicationContext

![](https://s1.ax1x.com/2020/09/21/wbL2ee.png)

### ResourceLoader

加载资源的策略。ApplicationContext 需要提供这个功能，并支持扩展 ResourcePatternResolver。

DefaultResourceLoader 是一个独立的实现，可在 ApplicationContext 外部使用，也由 
ResourceEditor 使用。

当在 ApplicationContext 中运行时，可以使用特定上下文的资源加载策略从 Strings 填充 Resource 和 
Resource array 类型的Bean属性。

### ResourcePatternResolver

将 location pattern 解析为 Resource 对象的策略接口。

PathMatchingResourcePatternResolver 是一个独立的实现，可在 ApplicationContext 外部使用，
ResourceArrayPropertyEditor 也使用它来填充 Resource array bean 属性。

可以与任何类型的 location pattern 一起使用: 输入模式必须与策略实施相匹配。该接口仅指定转换方法，
而不是特定的模式格式。

这个接口也建议一个新的 resource prefix "classpath*:" 用于匹配类路径上的所有资源。
请注意，在这种情况下，资源位置应为不带占位符的路径。JAR files 或者 classes 目录中可以包含
多个同名的文件。

### ApplicationEventPublisher

事件发布功能的封装接口。

### EnvironmentCapable

暗示组件包含和暴露一个 Environment 引用。

所有的 Spring application contexts 都是 EnvironmentCapable，并且该接口主要用于在接受 
BeanFactory 实例的框架方法中执行 instanceof 检查，以便可以与 environment 进行交互
(如果实际上是ApplicationContext实例)。

ConfigurableApplicationContext 重新定义了 getEnvironment() 方法，并且缩小了签名，
返回 ConfigurableEnvironment。结果是 Environment 对象是“只读的”，直到从 
ConfigurableApplicationContext 访问它为止，此时也可以对其进行配置。

### MessageSource

解析 messages 的策略接口，支持 messages 的参数化和国际化。

Spring 为生产提供了两种现成的实现:
* ResourceBundleMessageSource: 建立在标准 ResourceBundle 之上，共享其局限性。
* ReloadableResourceBundleMessageSource: 高度可配置的，特别是在重新加载消息定义方面。

### ApplicationContext

application 提供配置的中心接口。当 application running 时，这是一个只读的，但是它的实现类支持
重新加载。

ApplicationContext 的功能:
* 继承自 ListableBeanFactory，提供访问 application components 的方法
* 继承自 ResourceLoader，提供以通用方式加载文件资源的能力
* 继承自 ApplicationEventPublisher，提供向已注册的 listeners 发布事件的能力
* 继承自 MessageSource，提供解析 messages，支持国际化的能力
* 继承自 parent context，在后代上下文中的定义将始终优先。例如，这意味着整个 Web application 都可以使用单个 parent context，而每个 servlet 都有其自己的 child context，child context 独立于任何其他 servlet 的 child context

除了标准的 BeanFactory 生命周期功能之外，ApplicationContext 实现检测和执行 
ApplicationContextAware，ResourceLoaderAware, ApplicationEventPublisherAware,
MessageSourceAware

### Lifecycle

定义 start/stop 生命周期控制的公共接口。典型的用法是控制异步处理。**注意: 这个接口并不意味着特定的
自动启动的语义。考虑使用 SmartLifecycle 实现自动启动**。

可以由 components(定义在 Spring context 中的 Spring bean) 和 containers(Spring ApplicationContext) 实现。
Containers 将传播 start/stop 信号给所有的 components。

可以用于直接调用或通过 JMX 进行管理操作。在后一种情况下，通常将使用 
InterfaceBasedMBeanInfoAssembler 定义 MBeanExporter，从而将活动控制的组件的可见性限制为 
Lifecycle 接口。

注意: 当前 Lifecycle 接口仅支持 top-level singleton beans. 
扩展 SmartLifecycle 接口提供与 application context 的启动和关闭阶段的复杂集成。

### ConfigurableApplicationContext

SPI 接口将由大多数 application contexts 实现，提供了一些工具来配置。

配置和生命周期方法被封装为了避免它们明显的调用 ApplicationContext client code。
当前方法应该仅仅在 startup and shutdown code 中使用。

### WebApplicationContext

为 web application 提供配置的接口。当 application running 时，这是一个只读的，但是它的实现类支持重新加载。

此接口将 getServletContext() 方法添加到通用的 ApplicationContext 接口中，并定义了
root context 必须在引导过程中绑定的众所周知的 application attribute name。

web application contexts 是 hierarchical 的，每个 application 有一个 root context，
每个 servlet 有它自己的 child context。

除了标准的 application context lifecycle 能力之外，WebApplicationContext 需要检测和执行
ServletContextAware。

### ConfigurableWebApplicationContext

可配置的 web application contexts 的接口。支持 ContextLoader 和 FrameworkServlet。

在调用 refresh 方法之前，这个接口的 setters 方法应该先被调用。它们不会自行导致 context 初始化。

### AnnotationConfigRegistry

annotation 配置的 application contexts 的公共接口。

### WebServerApplicationContext

创建和管理嵌入式 WebServer 生命周期。

### ConfigurableWebServerApplicationContext

提供工具去配置 WebServerApplicationContext

### DefaultResourceLoader

ResourceLoader 的默认实现。被 ResourceEditor 使用。

如果 location value 是 URL，将返回 UrlResource。如果不是 URL 或者是以 "classpath:"
开头的 URL，将返回 ClassPathResource。

* ClassLoader classLoader: 用于加载类路径上的 Resource
* Set\<ProtocolResolver\> protocolResolvers: 协议解析器
* Map\<Class\<?\>, Map\<Resource, ?\>\> resourceCaches: 

### AbstractApplicationContext

不强制用于配置的存储类型；简单地实现通用上下文功能。使用模板方法设计模式。

应该检测其内部 BeanFactory 中定义的特殊 bean，这个类自动注册定义在 content 中的
BeanFactoryPostProcessors, BeanPostProcessors, and ApplicationListeners。

MessageSource 可能也被提供给 context。ApplicationEventMulticaster 也被提供给 context，
默认是 SimpleApplicationEventMulticaster。

通过 DefaultResourceLoader 实现资源加载。将 non-URL 路径作为 class path resources 路径对待，

* String id: context 的唯一 id
* String displayName: context 的展示名字
* ApplicationContext parent: parent context
* ConfigurableEnvironment environment: context 的 Environment
* List\<BeanFactoryPostProcessor\> beanFactoryPostProcessors: BeanFactoryPostProcessors
* long startupDate: context 的启动时间(ms)
* AtomicBoolean active: 标记当前 context 是否 active
* AtomicBoolean closed: 标记当前 context 是否 closed
* Object startupShutdownMonitor: "refresh" and "destroy" 的同步监听器
* Thread shutdownHook: JVM shutdown hook 引用
* ResourcePatternResolver resourcePatternResolver: context 的 ResourcePatternResolver
* LifecycleProcessor lifecycleProcessor: 管理 context 中的 bean 的生命周期
* MessageSource messageSource: context 的 MessageSource
* ApplicationEventMulticaster applicationEventMulticaster: 发布事件的帮助类
* Set\<ApplicationListener\<?\>\> applicationListeners: 静态指定的 listeners
* Set\<ApplicationListener\<?\>\> earlyApplicationListeners: refresh 之前注册的 listeners
* Set\<ApplicationEvent\> earlyApplicationEvents: 设置 multicaster 之前发布的事件

### GenericApplicationContext

具有一个内部 DefaultListableBeanFactory 实例，并且不采用特定的 bean definition 格式。
为了重新读取 bean definition，实现了 BeanDefinitionRegistry。

典型的用法是通过 BeanDefinitionRegistry 注册各种各样的 bean definitions，
然后调用 AbstractApplicationContext.refresh() 实例化它们。

与为每次 refresh 创建一个新的内部 BeanFactory 实例的其他 ApplicationContext 实现相反，
此上下文的内部 BeanFactory 从一开始就可用，以便能够在其上注册 bean definitions。
AbstractApplicationContext.refresh() 可能只调用一次。

对于典型的 XML bean definitions 用例，缺少弹性，只能使用 XML bean definitions，
而不能使用混合任意类型的的 bean definitions 格式。这相当于 web environment 的
XmlWebApplicationContext。

* DefaultListableBeanFactory beanFactory: 内部的 BeanFactory，用于注册 bean definitions
* ResourceLoader resourceLoader: 资源加载器
* boolean customClassLoader: 标记是否自定义 ClassLoader
* AtomicBoolean refreshed: 标记是否已经 refresh

### GenericWebApplicationContext

适用于 web environments 的 GenericApplicationContext，实现 ConfigurableWebApplicationContext，
但不适用于 web.xml 中的声明性设置。相反，它是为编程设置而设计的，例如用于构建嵌套上下文或在
WebApplicationInitializers 中使用。

* ServletContext servletContext: servlet 上下文
* ThemeSource themeSource: web environment 中资源文件获取源(css, image)

### ServletWebServerApplicationContext

一个 WebApplicationContext，可用于从包含的 ServletWebServerFactory bean 进行自身引导。

从 ApplicationContext 自身中查找一个 ServletWebServerFactory bean 去创建，初始化，
运行一个 WebServer。ServletWebServerFactory 可自由使用标准 Spring 概念(如，依赖注入，
生命周期回调，属性占位符变量)。

定义在 context 中的任意 Servlet or Filter beans 将自动去注册到 web server 中。
在单 Servlet bean 模式下，'/' mapping 将被使用。如果 context 中存在多个 Servlet bean，
beanName 的小写将作为 mapping 的前缀。任意 beanName 为 dispatcherServlet 的 Servlet
将总是 mapping 到 '/'。Filter bean 将总是映射到所有的 URLs('/*')。

对于更多高级的配置，context 可以改为定义实现 ServletContextInitializer 接口的 Bean
(ServletRegistrationBeans and/or FilterRegistrationBeans)。为防止重复注册，
使用 ServletContextInitializer bean 将禁用自动注册 Servlet and Filter。

* WebServer webServer: web 服务
* ServletConfig servletConfig: servlet 配置
* String serverNamespace: server namespace

### AnnotationConfigServletWebServerApplicationContext

接受注解类作为输入的 ServletWebServerApplicationContext。

* AnnotatedBeanDefinitionReader reader: 注解类型的 BeanDefinition 读取器
* ClassPathBeanDefinitionScanner scanner: 类路径的 BeanDefinition 扫描器
* Set\<Class\<?\>\> annotatedClasses: 注解类型的 BeanDefinition 集合
* String[] basePackages: 待扫描的类路径

# Environment

![wOzh8g.png](https://s1.ax1x.com/2020/09/22/wOzh8g.png)

## PropertyResolver

针对任意底层资源的属性解析器

## ConfigurablePropertyResolver

提供用于访问和定制 ConversionService 的能力。

## AbstractPropertyResolver

针对任意底层资源的属性解析器的抽象基类

* ConfigurableConversionService conversionService: conversion 服务
* PropertyPlaceholderHelper nonStrictHelper: 不严格的属性占位符解析帮助类
* PropertyPlaceholderHelper strictHelper: 严格的属性占位符解析帮助类
* boolean ignoreUnresolvableNestedPlaceholders: 是否忽略无法解析的嵌入式占位符
* String placeholderPrefix: 占位符前缀
* String placeholderSuffix: 占位符后缀
* String valueSeparator: 默认值分隔符
* Set\<String\> requiredProperties: 必要的属性

## PropertySourcesPropertyResolver

针对任意底层 PropertySources 集合的解析属性值的 PropertyResolver

* PropertySources propertySources: 属性源集合

## Environment

代表当前正在运行的 application 的 environment。 为应用程序环境的两个关键方面建模: profiles and properties
与属性访问相关的方法通过 PropertyResolver 暴露。

当给定的 profile 是 active 时，以当前 profile 命名的 bean definitions 逻辑组将被注册到容器中。
可以通过 @Profile 给 bean 分配 profile。Environment 对象的作用是决定哪些 profile 是 active，
哪些 profile 是 default 的。

Properties 在大多数 applications 中是一个非常重要的角色，可能有多种来源: properties files, 
JVM system properties, system environment variables, JNDI, 
servlet context parameters, ad-hoc Properties objects, Maps。
环境对象与属性的关系是为用户提供方便的服务界面，用于配置属性源并从中解析属性。

在 ApplicationContext 中管理的 Bean 可以注册为 EnvironmentAware 或 @Inject Environment
以便直接查询 profile 状态或解析属性。

但是，在大多数情况下，应用程序级 Bean 无需直接与 Environment 交互，而可能必须将 ${...}
属性值替换为属性占位符配置程序，例如 PropertySourcesPlaceholderConfigurer，
该属性本身是 EnvironmentAware，自使用 \<context：property-placeholder/\>时，
Spring 3.1 默认情况下会注册。

必须通过从所有 AbstractApplicationContext 子类 getEnvironment() 方法返回的
ConfigurableEnvironment 接口完成环境对象的配置。请参阅 ConfigurableEnvironment Javadoc
以获取使用示例，这些示例演示在应用程序上下文 refresh() 之前对属性源进行的操作。

## ConfigurableEnvironment

提供设置 active and default profiles 和操纵底层属性源的能力。允许客户端去设置和校验
required properties, 自定义 conversion service。

Property sources 可以被添加，删除，重排序，替换。

## AbstractEnvironment

* Set\<String\> activeProfiles: active 的 profile
* Set\<String\> defaultProfiles: default 的 profile
* MutablePropertySources propertySources: 属性源迭代器
* ConfigurablePropertyResolver propertyResolver: 属性解析器

## StandardEnvironment

'standard' (i.e. non-web) applications 的 Environment。

添加了两个默认的属性源: system properties 和 system environment variables

## ConfigurableWebEnvironment

在 ServletContext 和 ServletConfig 最早的可用时刻初始化 servlet-related PropertySource

## StandardServletEnvironment

Servlet-based web applications 中使用的 Environment。

贡献 ServletConfig, ServletContext, and JNDI-based PropertySource 实例。

# BeanDefinition 

## BeanDefinition 

![wjc8iT.png](https://s1.ax1x.com/2020/09/23/wjc8iT.png)

### BeanDefinition 

bean 实例的 BeanDefinition 描述，其中包含 property values，constructor argument values 等。

这仅仅是一个最小的接口：主要目的是允许 BeanFactoryPostProcessor 内省和修改 property values
和 bean 的其他元数据。

* String SCOPE_SINGLETON: singleton Scope
* String SCOPE_PROTOTYPE: prototype Scope
* int ROLE_APPLICATION: 用户定义的 BeanDefinition
* int ROLE_SUPPORT: 用于支持框架的 BeanDefinition
* int ROLE_INFRASTRUCTURE: 框架的基础设施的 BeanDefinition

### AnnotatedBeanDefinition

暴露出 bean 的注解元信息，AnnotationMetadata

### AbstractBeanDefinition

成熟 BeanDefinition 的基类。autowire 常量匹配定义在 AutowireCapableBeanFactory 中的常量。

* String SCOPE_DEFAULT: 默认的 Scope
* int AUTOWIRE_NO: 无自动注入
* int AUTOWIRE_BY_NAME: 按属性名自动注入
* int AUTOWIRE_BY_TYPE: 按属性类型自动注入
* int AUTOWIRE_CONSTRUCTOR: 按构造器自动注入
* int DEPENDENCY_CHECK_NONE: 不进行依赖校验
* int DEPENDENCY_CHECK_OBJECTS: 依赖校验对象引用
* int DEPENDENCY_CHECK_SIMPLE: 依赖校验 simple 属性，参见 BeanUtils#isSimpleProperty
* int DEPENDENCY_CHECK_ALL: 依赖校验所有属性
* String INFER_METHOD: 自动推测 destroy method name，"close" and "shutdown"


* Object beanClass: bean class
* String scope: bean string scope
* boolean abstractFlag: bean class abstract flag
* Boolean lazyInit: bean lazy flag
* int autowireMode: 属性自动注入的模式
* int dependencyCheck: 依赖校验
* String[] dependsOn: 注解 @DependsOn 的 value 值
* boolean autowireCandidate: bean 是否作为自动注入的候选者
* boolean primary: bean 是否为 primary 的
* Map\<String, AutowireCandidateQualifier\> qualifiers: bean 的 Qualifier 标记
* Supplier\<?\> instanceSupplier: bean 实例的提供者
* boolean nonPublicAccessAllowed: 是否允许访问非 public 方法
* boolean lenientConstructorResolution: 宽松的构造器解析
* String factoryBeanName: 工厂 beanName
* String factoryMethodName: 工厂方法名字
* ConstructorArgumentValues constructorArgumentValues: 构造器参数值
* MutablePropertyValues propertyValues: bean 属性值
* MethodOverrides methodOverrides: bean 的方法覆盖
* String initMethodName: init 方法名
* String destroyMethodName: destroy 方法名
* boolean enforceInitMethod: 增强 init 方法
* boolean enforceDestroyMethod: 增强 destroy 方法
* boolean synthetic: BeanDefinition 是否是合成的
* int role: BeanDefinition 的 role
* String description: BeanDefinition 的描述
* Resource resource: BeanDefinition 的来源

### ChildBeanDefinition

从其父级继承设置的 Bean 的 Bean definition。子 bean definition 对父 bean definition 有固定的依赖性。

子 bean definition 从父 bean definition 继承: constructor argument values,
property values, method overrides 合并父子值；init method, destroy method,
static factory method 覆盖父值；depends on, autowire mode, dependency check,
singleton, lazy init 总是从子中获取。

* String parentName: 父 bean definition 的 beanName

### RootBeanDefinition

定义表示合并的 bean definition，该定义在运行时支持 Spring BeanFactory 中的特定 bean。
它可能是由多个相互继承的原始 bean 定义创建的，通常定义为 GenericBeanDefinitions。
root bean definition 实际上是运行时的统一 bean definition 视图。

root bean definition 也可能用于配置阶段去注册 individual bean definitions。
从 Spring 2.5 开始，更喜欢以编程方式注册 GenericBeanDefinition，GenericBeanDefinition
的优点: 动态定义 parent dependencies， 不会硬编码 role 为 root bean definition。

* BeanDefinitionHolder decoratedDefinition: BeanDefinition 的装饰器
* AnnotatedElement qualifiedElement: BeanDefinition 的 qualified 注解元素
* boolean stale: 标记 BeanDefinition 是否**仍然**需要 re-merged
* boolean allowCaching: 标记 BeanDefinition 是否允许缓存
* boolean isFactoryMethodUnique: 是否有唯一的 FactoryMethod
* ResolvableType targetType: 目标类型
* Class\<?\> resolvedTargetType: 缓存推断出来的 beanClass
* Boolean isFactoryBean: 是否为 FactoryBean
* ResolvableType factoryMethodReturnType: 工厂方法返回的类型
* Method factoryMethodToIntrospect: 缓存唯一的工厂方法候选者用于自省
* Object constructorArgumentLock: 构造器参数锁
* Executable resolvedConstructorOrFactoryMethod: 创建 bean 的构造器或工厂方法
* boolean constructorArgumentsResolved: 构造器参数是否已解析
* Object[] resolvedConstructorArguments: 已解析的构造器参数
* Object[] preparedConstructorArguments: 部分准备好的构造器参数
* Object postProcessingLock: 后处理锁
* boolean postProcessed: 是否已经执行 MergedBeanDefinitionPostProcessor
* Boolean beforeInstantiationResolved: 是否已经执行 before-instantiation post-processor
* Set\<Member\> externallyManagedConfigMembers: 额外的管理配置 Member
* Set\<String\> externallyManagedInitMethods: 额外的管理 InitMethod
* Set\<String\> externallyManagedDestroyMethods: 额外的管理 DestroyMethod

### ClassDerivedBeanDefinition

与 Kotlin 相关的 BeanDefinition

### ConfigurationClassBeanDefinition

RootBeanDefinition 标记子类用于表示一个 bean definition 是从配置类创建，而不是任何其他配置源。
用于 bean overriding 情况下，有必要确定 bean definition 是否被外部创建。

* AnnotationMetadata annotationMetadata: 配置类的注解元数据
* MethodMetadata factoryMethodMetadata: @Bean 方法的元数据

### GenericBeanDefinition

用于 standard bean definition。特定的 class 加上可选的 constructor argument values and property values
另外，可以通过 "parentName" 属性灵活地配置从父 bean definition 派生的内容。

通常情况下，用于注册用户可见的 bean definition，后处理器可能对其进行操作，甚至可能重新配置 parentName。
如果父/子关系是预先确定的，请使用 RootBeanDefinition / ChildBeanDefinition。

* String parentName: 父 bean definition 的 beanName

### AnnotatedGenericBeanDefinition

暴露注解元数据的 GenericBeanDefinition

包装有注解配置的指定 class 的 BeanDefinition

* AnnotationMetadata metadata: 注解元数据
* MethodMetadata factoryMethodMetadata: 工厂方法元数据

### ScannedGenericBeanDefinition

基于 ASM ClassReader 支持暴露注解元数据的 GenericBeanDefinition

它不会早期加载 Class。它仅仅通过 .class 文件读取数据。它在功能上等价于 
new AnnotatedGenericBeanDefinition(AnnotationMetadata)，但是通过已扫描的类型 bean
与通过其他方式注册或检测的类型 bean 进行区分。

* AnnotationMetadata metadata: 注解元数据

## AttributeAccessor

![wxPtzV.png](https://s1.ax1x.com/2020/09/23/wxPtzV.png)

### AttributeAccessor

用于附接和访问任意对象元数据的通用合同。

### AttributeAccessorSupport

AttributeAccessor 的统一抽象实现

* Map\<String, Object\> attributes: 属性值的存储地方

### BeanMetadataAttributeAccessor

持有 BeanMetadataAttribute 对象，用于跟踪 definition 的来源

* Object source: 元数据元素的配置源

### PropertyValue

持有信息和值得 individual bean property，使访问值更具弹性

value 不需要是最终需要的类型: 一个 BeanWrapper 实现应该处理任意需要的转换，
因为这个对象不知道任何关于将被应用到的对象。

* String name: 属性值名称
* Object value: 属性值
* boolean optional: 是否可选
* boolean converted: 是否已经转换
* Object convertedValue: 已转换的属性值
* Boolean conversionNecessary: 属性值是否需要转换
* Object resolvedTokens: 解析的属性路径标记

### AutowireCandidateQualifier

解决自动装配候选者的限定符。bean definition 包含一个或多个 qualifiers 开启细粒度的针对
field or parameter 上的注解的自动注入。

* String VALUE_KEY: 保存值得 key 的名称
* String typeName: 类型的 Class name

## BeanMetadataElement

![wxkZGR.png](https://s1.ax1x.com/2020/09/23/wxkZGR.png)

### BeanMetadataElement

bean 元对象元素，携带配置源对象

### BeanMetadataAttribute

bean definition 中 key-value 的属性值

* String name: 属性值名称
* Object value: 属性值
* Object source: 元数据元素的配置源

### ValueHolder

constructor argument value 持有者，含有一个可选的类型属性，暗示真实的 constructor argument
类型。

* Object value: 属性值
* String type: 真实的属性类型
* String name: 属性值名称
* Object source: 元数据元素的配置源
* boolean converted: 是否已经转换
* Object convertedValue: 已转换的属性值

### TypedStringValue

持有一个类型的 string 值，可以添加到 bean definitions 中，用于显式指定特定的目标类型的 string 值，
如，collection 的元素值。

它仅仅保存 string 值和目标类型。真实的转换在 bean factory 中执行。

* String value: 类型的 string 值
* Object targetType: 目标类型
* Object source: 元数据元素的配置源
* String specifiedTypeName: 指定的类型名称
* boolean dynamic: 是否是动态的

### ManagedProperties

Spring-managed 的 Properties 实例，支持合并 parent/child definitions

* Object source: 元数据元素的配置源
* boolean mergeEnabled: 是否应该合并父子 collection 的值

### ManagedMap

collection class 得 tag， 用于持有管理的 Map 值，可能包含运行时的 bean references。

* Object source: 元数据元素的配置源
* String keyTypeName: Map key 类型名称
* String valueTypeName: Map value 类型名称
* boolean mergeEnabled: 是否应该合并父子 collection 的值

### ManagedSet

collection class 得 tag， 用于持有管理的 Set 值，可能包含运行时的 bean references。

* Object source: 元数据元素的配置源
* String elementTypeName: 元素类型名称
* boolean mergeEnabled: 是否应该合并父子 collection 的值

### ManagedList

collection class 得 tag， 用于持有管理的 List 值，可能包含运行时的 bean references。

* Object source: 元数据元素的配置源
* String elementTypeName: 元素类型名称
* boolean mergeEnabled: 是否应该合并父子 collection 的值

### ManagedArray

collection class 得 tag， 用于持有管理的 Array 值，可能包含运行时的 bean references。

* Class\<?\> resolvedElementType: 运行时创建的目标数组的类型

### BeanReference

以抽象方式公开对 Bean 名称的引用的接口。这个接口不一定暗示一个真实的 bean 实例引用；
它只表达了一个 beanName 的逻辑引用。

bean reference 持有者的任意类型。

### RuntimeBeanNameReference

不可变的占位符类，工厂中的指向另一个 beanName 的引用的属性值对象，在运行时得到解析。

* String beanName: 目标 bean 的名字
* Object source: 元数据元素的配置源

### RuntimeBeanReference

不可变的占位符类，工厂中的指向另一个 bean 的引用的属性值对象，在运行时得到解析。

* String beanName: 目标 bean 的名字
* Class\<?\> beanType: bean class
* boolean toParent: bean 是否在 parent factory 中
* Object source: 元数据元素的配置源

### MethodOverride

表示一个 IoC 容器中管理的对象的方法覆盖对象。

请注意，override 机制不打算作为插入横切代码的通用方法: 请使用 AOP

* String methodName: 方法名字
* boolean overloaded: 是否已经负载
* Object source: 元数据元素的配置源

### LookupOverride

表示一个在相同 IoC context 中 looks up 一个对象的方法覆盖对象。

符合查找覆盖条件的方法必须没有参数。

* String beanName: beanName
* Method method: 覆盖的方法

### ReplaceOverride

表示 IoC container 一个任意的方法覆盖。

任意非 final 的方法都可以被覆盖，不管它的 parameters and return types。

* String methodReplacerBeanName: 方法覆盖者的 beanName
* List\<String\> typeIdentifiers: 方法参数的类型标识

### AliasDefinition

表示在处理过程中已经注册了一个别名。

* String beanName: beanName
* String alias: 别名
* Object source: 元数据元素的配置源

### ImportDefinition

表示在处理过程中已经处理了一个 import。

* String importedResource: import 的资源
* Resource[] actualResources: 真实的资源
* Object source: 元数据元素的配置源

### DefaultsDefinition

defaults definition 的标记接口。

基于 document defaults 的指定在 XML document 的 root tag level 中

### DocumentDefaultsDefinition

简单的 Javabean 对象，持有`<beans>`级别的默认值

* String lazyInit
* String merge
* String autowire
* String autowireCandidates
* String initMethod
* String destroyMethod
* Object source

### ComponentDefinition

描述某些 configuration context 中呈现的 BeanDefinitions 和BeanReferences 集合的逻辑视图的接口。

通过引入可插拔的自定义 XML 标记，现在可以使单个逻辑配置实体（在本例中为 XML 标记）
创建多个 BeanDefinitions 和 RuntimeBeanReference，以便为最终用户提供更简洁的配置和更大的便利。
因此，不能再假定每个配置实体（例如 XML 标记）都映射到一个 BeanDefinition。
对于希望提供可视化或配置 Spring 应用程序支持的工具供应商和其他用户，重要的是要有某种适当的机制将 
BeanFactory 中的 BeanDefinitions 与配置数据相关联，从而对最终用户具有特定的意义。这样，
NamespaceHandler 实现就可以为每个要配置的逻辑实体以 ComponentDefinition 的形式发布事件。
然后，第三方可以订阅这些事件，从而允许以用户为中心的bean元数据视图。

每个 ComponentDefinition 都有一个特定于配置的源对象。对于基于 XML 的配置，
通常是包含用户提供的配置信息的 Node。除此之外，ComponentDefinition 中包含的每个
BeanDefinition 都有其自己的源对象，该对象可以指向一组不同的，更特定的配置数据。除此之外，
各个 bean 元数据片段（例如 PropertyValues）可能还具有提供更详细级别的源对象。源对象提取通过
SourceExtractor 处理，可以根据需要自定义。

尽管可以通过 getBeanReferences() 直接访问重要的 BeanReferences，但是工具可能希望检查所有
BeanDefinitions 以收集完整的 BeanReferences 集。需要提供实现以提供所有 BeanReferences，
而这些 BeanReferences 是验证整个逻辑实体的配置所必需的，还包括为用户提供完整的配置可视化所必需的那些。
可以预期，某些 BeanReferences 对于验证或对配置的用户视图而言并不重要，因此可以将其省略。
工具可能希望显示通过提供的 BeanDefinitions 派生的任何其他 BeanReferences，但这不是典型的情况。

工具可以通过检查角色标识符来确定所包含的 BeanDefinitions 的重要性。该角色实质上是对该工具的提示，
说明配置提供者认为 BeanDefinition 对最终用户有多重要。期望工具不会显示给定 ComponentDefinition 
的所有 BeanDefinition，而是根据角色进行过滤。工具可以选择使此筛选用户可配置。
应特别注意基础结构角色标识符。使用此角色进行分类的 BeanDefinitions 对最终用户而言完全不重要，
仅出于内部实现原因才需要。

### AbstractComponentDefinition

ComponentDefinition 的基本实现，提供了 getDescription() 的基本实现，该实现将委托给
ComponentDefinition.getName()。还提供了 toString() 的基本实现，该实现将 getDescription()
委托给了建议的实现策略。还提供了返回空数组的 getInnerBeanDefinitions() 和 getBeanReferences()
的默认实现。

### CompositeComponentDefinition

持有一个或多个 ComponentDefinition 实例，聚合它们在一个命名的 components 组中。

* String name: 组名
* Object source: 元数据元素的配置源
* List\<ComponentDefinition\> nestedComponents: ComponentDefinition 实例集合

### BeanDefinitionHolder

持有 BeanDefinition, beanName, aliases。可注册为一个内部 bean 的占位符。

也可用于内部 BeanDefinition 编程注册。如果你不关心 BeanNameAware 之类，
注册 RootBeanDefinition 或 ChildBeanDefinition 就够好了。

* BeanDefinition beanDefinition: BeanDefinition
* String beanName: beanName
* String[] aliases: 别名

### BeanComponentDefinition

基于 standard BeanDefinition 的 ComponentDefinition，暴露一个给定的 bean definition
和内部 bean definitions 与 bean 间的引用。

* BeanDefinition[] innerBeanDefinitions: 内部 bean definitions
* BeanReference[] beanReferences: bean 引用

# Lifecycle

![wz2k6S.png](https://s1.ax1x.com/2020/09/24/wz2k6S.png)

## SmartLifecycle

Lifecycle 接口的扩展，用于那些需要按特定顺序 refresh 和/或 shutdown ApplicationContext
启动时的对象。

isAutoStartup() 返回值指示是否应在刷新上下文时启动此对象。接受回调的 stop(Runnable)
方法对于具有异步关闭过程的对象很有用。此接口的任何实现都必须在关闭完成时调用回调的 run() 方法，
以避免在整个 ApplicationContext 关闭中不必要的延迟。

此接口扩展了 Phased，并且 getPhase() 方法的返回值指示此 Lifecycle 组件应在其中启动和停止的阶段。
启动过程以最低的相位值开始，以最高的相位值结束(Integer.MIN_VALUE 是可能的最低值，而
Integer.MAX_VALUE 是可能的最高值)。关闭过程将应用相反的顺序。
具有相同值的任何组件将在同一阶段内任意顺序。

例如：如果组件 B 依赖于已经启动的组件 A，则组件 A 的相位值应低于组件 B。在关闭过程中，
组件 B 将在组件 A 之前停止。

任何显式的“依赖”关系都将优先于阶段顺序，以便从属 bean 始终在其依赖之后开始，并始终在其依赖之前停止。

如果上下文中没有实现 SmartLifecycle 的任何 Lifecycle 组件都将被视为具有相位值 0。
这将允许 SmartLifecycle 组件在这些 Lifecycle 组件之前启动（如果SmartLifecycle组件的相位值为负）
或 SmartLifecycle 组件。如果 SmartLifecycle 组件的相位值为正，则可能在这些
Lifecycle 组件之后启动。

请注意，由于 SmartLifecycle 支持自动启动，因此无论如何在启动应用程序上下文时通常都会初始化
SmartLifecycle bean 实例。结果，bean 定义 lazy-init 标志对 SmartLifecycle bean
的实际影响非常有限。

## LifecycleProcessor

ApplicationContext 中处理 Lifecycle beans 的策略接口

## DefaultLifecycleProcessor

LifecycleProcessor 的默认策略

* long timeoutPerShutdownPhase: 每个停顿阶段的超时时间
* boolean running: ApplicationContext 是否正在运行
* ConfigurableListableBeanFactory beanFactory: BeanFactory

# BeanPostProcessor

![wzfl1P.png](https://s1.ax1x.com/2020/09/24/wzfl1P.png)

## BeanPostProcessor

Factory hook, 允许对一个新的 bean 实例做自定义的修改. 如, 通过
postProcessBeforeInitialization(Object, String) 给标记接口填充属性或通过
postProcessAfterInitialization(Object, String) 使用代理包装 bean 实例.

bean definition 的形式注册支持 PriorityOrdered and Ordered 语义，编程方式仅支持
Ordered 语义, 不支持 @Order 注解

## LoadTimeWeaverAwareProcessor

BeanPostProcessor 实现，它将上下文的默认 LoadTimeWeaver 传递给实现
LoadTimeWeaverAware 接口的 bean。

如果实际可以使用默认的 LoadTimeWeaver，则应用程序上下文将自动在其基础 bean 工厂中注册它。

应用程序不应直接使用此类。

## MethodValidationPostProcessor

委托 JSR-303 提供者执行方法级别的校验。校验参数或返回值。

## BeanValidationPostProcessor

简单的 BeanPostProcessor，它检查 Spring 管理的 bean 中的 JSR-303 约束注释，并在调用
bean 的 init 方法（如果有）之前抛出约束异常情况下引发初始化异常。

## AsyncAnnotationBeanPostProcessor

通过将相应的 AsyncAnnotationAdvisor 添加到公开的代理
（现有的AOP代理或实现目标的所有目标的新生成的代理），自动将异步调用行为应用于在类或方法级别上带有
Async 注解的任何 Bean 接口）。

可以提供负责异步执行的 TaskExecutor 以及指示应异步调用方法的注解类型。如果未指定注释类型，
则此后处理器将检测 Spring 的 @Async 注解以及 EJB 3.1 javax.ejb.Asynchronous 注解。

对于具有 void 返回类型的方法，调用者无法访问在异步方法调用期间引发的任何异常。可以指定
AsyncUncaughtExceptionHandler 来处理这些情况。

注意：默认情况下，基础异步顾问程序先于现有顾问程序应用，以便在调用链中尽早切换到异步执行。

* Supplier\<Executor\> executor: 异步执行者提供者
* Supplier\<AsyncUncaughtExceptionHandler\> exceptionHandler: AsyncUncaughtExceptionHandler 提供者
* Class\<? extends Annotation\> asyncAnnotationType: 异步注解类型

## ApplicationContextAwareProcessor

EnvironmentAware，EmbeddedValueResolverAware，ResourceLoaderAware，
ApplicationEventPublisherAware，MessageSourceAware，ApplicationContextAware 处理者

## BeanPostProcessorChecker

当 BeanPostProcessor 实例化的时候创建 BeanPostProcessor，将打印 info 信息。

## WebServerFactoryCustomizerBeanPostProcessor

将 WebServerFactoryCustomizer 应用到 WebServerFactory

## DataSourceInitializedPublisher

发布 DataSourceSchemaCreatedEvent 事件，应该仅仅通过内部的 Registrar 注册

## DataSourceInitializerPostProcessor

当出现 DataSource 时，确保实例化 DataSourceInitializer

## ConfigurationPropertiesBindingPostProcessor

绑定 PropertySources 到 @ConfigurationProperties bean

## ServletContextAwareProcessor

处理 ServletContextAware，ServletConfigAware

## WebApplicationContextServletContextAwareProcessor

用于为 ServletContextAwareProcessor 提供 ServletContext，ServletConfig

## InstantiationAwareBeanPostProcessor

bean 实例化之后，但是 properties 被设置或自动注入发生之前

通常用于抑制特定目标 bean 的默认实例化，例如创建具有特殊 TargetSource 的代理（池目标，
延迟初始化目标等），或实现其他注入策略，例如字段注入。

注意：此接口是专用接口，主要供框架内部使用。建议尽可能实现普通的 BeanPostProcessor 接口，
或从 InstantiationAwareBeanPostProcessorAdapter 派生，以免对该接口进行扩展。

## SmartInstantiationAwareBeanPostProcessor

用于推测 BeanType，决定 Candidate Constructors，获取 Early Bean Reference

## ImportAwareBeanPostProcessor

AutowiredAnnotationBeanPostProcessor's postProcessProperties 执行之前，
注入 BeanFactory，尝试去自动注入其它的配置 beans。

处理 ImportAware

## MergedBeanDefinitionPostProcessor

运行时合并 bean definitions。

例如，postProcessMergedBeanDefinition(RootBeanDefinition, Class\<?\>, String)
方法可以对 bean definition 进行自省，以便在实际进行后期处理之前准备一些缓存 Bean 实例元数据。
还允许修改 bean definition，但只允许修改实际上用于并行修改的定义属性。本质上，这仅适用于
RootBeanDefinition 本身定义的操作，不适用于其基类的属性。

## AutowiredAnnotationBeanPostProcessor

自动注入被 @Autowired and @Value 注解的 fields，setter methods，任意配置方法。(JSR-330's @Inject)

任意给定的 bean class 只能有一个 constructor 可以声明 'required' 属性为 true，暗示用于创建 bean。
如果有多个 constructor 被 @Autowired(required = false) 注解，那么它们将被作为 candidates。
candidates 排序，参数最多，默认 constructor，单独的 constructor

在构造任何 bean 之后，调用任何配置方法之前立即注入字段。这样的配置字段不必是公共的。

Config 方法可以具有任意名称和任意数量的参数。这些参数中的每个参数都将与 Spring 容器中的匹配
bean 自动连接。Bean 属性设置器方法实际上只是这种常规 config 方法的特例。Config方法不必是公共的。

默认的 AutowiredAnnotationBeanPostProcessor 将通过 "context:annotation-config" 和
"context:component-scan" XML标签进行注册。如果要指定自定义
AutowiredAnnotationBeanPostProcessor bean 定义，请删除或关闭那里的默认注释配置。

注意：注解注入将在 XML 注入之前执行；因此，对于通过这两种方法连接的属性，后一种配置将覆盖前者。

除了上面讨论的常规注入点之外，此后处理器还处理 Spring 的 @Lookup 批注，
该批注标识在运行时由容器替换的查找方法。这本质上是 getBean（Class，args）和
getBean（String，args）的类型安全版本。有关详细信息，请参见@Lookup的javadoc。

* Set\<Class\<? extends Annotation\>\> autowiredAnnotationTypes: 自动注入的注解类型
* String requiredParameterName: 判断是否必要的属性名
* boolean requiredParameterValue: 判断是否必要的属性值
* int order: BeanPostProcessor 的顺序
* ConfigurableListableBeanFactory beanFactory: BeanFactory
* Set\<String\> lookupMethodsChecked: lookupMethod 校验
* Map\<Class\<?\>, Constructor\<?\>[]\> candidateConstructorsCache: 候选构造器缓存
* Map\<String, InjectionMetadata\> injectionMetadataCache: 注入元数据缓存

## DestructionAwareBeanPostProcessor

增加了一个毁灭前的回调。典型的使用将是来调用特定豆类型的自定义破坏回调，匹配相应的初始化回调。

## SimpleServletPostProcessor

在初始化 bean 实例之后，将使用 ServletConfig 调用 Servlet 的 init 方法，该 ServletConfig
包含 Servlet 的 bean 名称和运行它的 ServletContext。

在销毁bean实例之前，将调用Servlet destroy。

请注意，此后处理器不支持Servlet初始化参数。实现 Servlet 接口的 Bean 实例应该像其他任何
Spring Bean 一样进行配置，即通过构造函数参数或 Bean 属性进行配置。

为了在普通 Servlet 容器中以及在 Spring 上下文中作为 Bean 重用 Servlet 实现，请考虑从
Spring 的 HttpServletBean 基类派生而来，该基类将 Servlet 初始化参数用作 Bean 属性，
同时支持标准 Servlet 和 Spring Bean 初始化样式。

或者，考虑使用 Spring 的 ServletWrappingController 包装 Servlet。这特别适用于现有的
Servlet 类，允许指定 Servlet 初始化参数等。

* boolean useSharedServletConfig: 是否使用共享的 ServletConfig
* ServletContext servletContext
* ServletConfig servletConfig

## ScheduledAnnotationBeanPostProcessor

将 @Scheduled 方法使用 TaskScheduler 执行。

使用 \<task:annotation-driven\> 或 @EnableScheduling 将自动注册当前 BeanPostProcessor

自动推测容器中的任意  SchedulingConfigurer 实例，允许配置 scheduler 用于细粒度的控制 task。

* String DEFAULT_TASK_SCHEDULER_BEAN_NAME: 默认的 taskScheduler beanName
* ScheduledTaskRegistrar registrar: ScheduledTask 的注册者
* Object scheduler: scheduler 对象
* StringValueResolver embeddedValueResolver: 嵌入式值解析对象
* String beanName
* BeanFactory beanFactory
* ApplicationContext applicationContext
* Set\<Class\<?\>\> nonAnnotatedClasses: 非注解 Class
* Map\<Object, Set\<ScheduledTask\>\> scheduledTasks: scheduled 任务

## ApplicationListenerDetector

用于推测 bean 是否实现了 ApplicationListener。不能可靠地检测到这种捕捞豆
getBeanNamesForType 及相关业务只针对顶级 bean 的工作。

随着标准的 Java 序列化，该处理器后不会得到序列化为的一部分 DisposableBeanAdapter 开始。
然而，替代序列化机制，DisposableBeanAdapter.writeReplace 可能无法得到完全使用，
所以我们防守纪念这个后处理器的现场状态。

* AbstractApplicationContext applicationContext
* Map\<String, Boolean\> singletonNames: ApplicationListener 是否为单例

## InitDestroyAnnotationBeanPostProcessor

执行被注解的 init and destroy 方法。

可以通过 "initAnnotationType" 和 "destroyAnnotationType" 
属性来配置此后处理器检查的实际注释类型。可以使用任何自定义注释，因为没有必需的注释属性。

初始化和销毁注释可以应用于任何可见性的方法：public, package-protected, protected, or private。
可以注释多个这样的方法，但是建议分别仅注释一个单一的init方法和destroy方法。

Spring 的 CommonAnnotationBeanPostProcessor 开箱即用地支持 JSR-250 PostConstruct
和 PreDestroy 注释，分别作为 init 注释和 destroy 注释。此外，它还支持资源注释，
用于注释驱动的命名 bean 注入。

* Class\<? extends Annotation\> initAnnotationType: init 注解类型
* Class\<? extends Annotation\> destroyAnnotationType: destroy 注解类型
* int order: BeanPostProcessor 顺序
* Map\<Class\<?\>, LifecycleMetadata\> lifecycleMetadataCache: 生命周期元数据缓存

## CommonAnnotationBeanPostProcessor

BeanPostProcessor 实现支持开箱即用的常见 Java 注释，特别是 javax.annotation 包中的
JSR-250 注释。这些常见的 Java 注释在许多 Java EE 5 技术（例如JSF 1.2）以及 Java 6 的
JAX-WS 中都受支持。

该后处理器通过继承具有预配置注释类型的 InitDestroyAnnotationBeanPostProcessor 来支持
PostConstruct 和 PreDestroy 注释（分别作为init注释和destroy注释）。

中心元素是用于注释驱动的命名 Bean 注入的 Resource 注释，默认情况下是从包含的
Spring BeanFactory 中进行的，只有 JNDI 中解析了 mappedName 引用。"alwaysUseJndiLookup"
标志针对名称引用和默认名称强制执行与标准 Java EE 5 资源注入等效的 JNDI 查找。目标 bean
可以是简单的 POJO，除了必须匹配的类型之外，没有其他特殊要求。

还支持 JAX-WS WebServiceRef 注释，类似于 Resource，但具有创建特定 JAX-WS 服务端点的功能。
这可以按名称指向显式定义的资源，也可以对本地指定的 JAX-WS 服务类进行操作。最后，该后处理器还支持
EJB 3 EJB 注释，这也类似于 Resource，并具有为回退检索指定本地 bean 名称和全局 JNDI 名称的功能。
在这种情况下，目标 Bean 可以是普通的 POJO 以及 EJB 3 会话 Bean。

此后处理器支持的通用注释在 Java 6（JDK 1.6）和 Java EE 5/6 中可用（Java EE 5/6
也为其独立注释提供了一个独立的 jar，允许在任何基于 Java 5 的应用程序中使用）。

注意：默认的 CommonAnnotationBeanPostProcessor 将通过 "context:annotation-config" and
"context:component-scan" XML标签进行注册。如果要指定自定义
CommonAnnotationBeanPostProcessor bean 定义，请删除或关闭那里的默认注释配置！

注意：注解注入将在XML注入之前执行；因此，对于通过这两种方法连接的属性，后一种配置将覆盖前者。

* Class\<? extends Annotation\> webServiceRefClass
* Class\<? extends Annotation\> ejbClass
* Set\<Class\<? extends Annotation\>\> resourceAnnotationTypes
* Set\<String\> ignoredResourceTypes: 忽略的 Resource 类型
* boolean fallbackToDefaultTypeMatch: 回退到默认的类型匹配
* boolean alwaysUseJndiLookup: 允许使用 JNDI 查找
* BeanFactory jndiFactory: SimpleJndiBeanFactory
* BeanFactory resourceFactory
* BeanFactory beanFactory
* StringValueResolver embeddedValueResolver
* Map\<String, InjectionMetadata\> injectionMetadataCache: 注入元数据缓存



