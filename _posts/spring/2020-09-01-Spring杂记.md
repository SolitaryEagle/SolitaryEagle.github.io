---
layout:     post
title:      Spring 杂记
subtitle:   Spring 杂记
date:       2020-09-01
author:     Eagle Cool
header-img: img/post-bg-ios9-web.jpg
catalog: 	true
tags:       Spring
---
# 控制反转（IOC）

系统依赖对象的获得被反转了，由自身实现反转为外部注入。控制反转的实现方式有**依赖注入**和**依赖查找**。
Spring Framework 主要采用**依赖注入**来实现控制反转，但其也实现了*依赖查找*。

# Spring IoC Container

* BeanFactory 提供了一种高级的配置机制，能够管理任何类型的对象。
* ApplicationContext 相较于 BeanFactory 提供了更多的功能，如下：
    * 易于集成 Spring’s AOP
    * 国际化的 Message resource 处理
    * 事件发布
    * 应用层特定的上下文，例如 Web 应用程序中使用的 WebApplicationContext

## BeanFactory

![](https://s1.ax1x.com/2020/09/18/w4Kr5T.png)

### BeanFactory

访问 Spring bean 容器的根接口。

bean 容器的基础客户端视图；ListableBeanFactory and ConfigurableBeanFactory 接口
是可用于特定目的接口。

这个接口被持有许多 bean definitions 的对象实现，每个 bean definition 都被一个唯一的 
beanName 标识。依赖于 bean definition，BeanFactory 将返回一个包含对象的独立实例
(Prototype 设计模式)，或者一个单独的共享实例(一种优于单例设计模式的选择，其中实例是 
Scope 内的单例实例)。返回实例的类型取决于 BeanFactory 的配置：API是相同的。从 
Spring 2.0 开始，更多的 Scope 可以使用在具体的 application context 中(如 Web 
环境的 "request" and "session")。

这种方法的要点是 BeanFactory 是 application components 的注册中心，配置中心(例如，
不再需要单个对象读取属性文件)。

注意，通过使用 setters or constructors 依赖注入 "push" 配置的形式配置对象，而不是
通过 BeanFactory lookup "pull" 配置的形式配置对象。Spring's 依赖注入功能是使用 
BeanFactory 和它的子接口实现的。

通常 BeanFactory 从一个配置源(如，XML)中加载 bean definitions，然后使用 
org.springframework.beans package 去配置 beans。然而，一个实现可以直接在 Java 
代码中返回它根据需要创建的 Java 对象。bean definitions 的存储方式没有任何限制: 
LDAP, RDBMS, XML, properties file 等。鼓励实现支持 bean 之间的引用。

与 ListableBeanFactory 的方法不同，BeanFactory 如果是 HierarchicalBeanFactory 
，那么它的操作总是校验 parent BeanFactory。如果一个 bean 在当前 BeanFactory 中没有
被发现，直接 parent BeanFactory 将被访问。当前 BeanFactory 中的 bean 应该覆盖任何
parent BeanFactory 中同名的 bean。

BeanFactory 的实现应该尽可能的支持标准的 bean 生命周期接口。

initialization methods: 
1. BeanNameAware's setBeanName
2. BeanClassLoaderAware's setBeanClassLoader
3. BeanFactoryAware's setBeanFactory
4. EnvironmentAware's setEnvironment
5. EmbeddedValueResolverAware's setEmbeddedValueResolver
6. ResourceLoaderAware's setResourceLoader (only applicable when running in an application context)
7. ApplicationEventPublisherAware's setApplicationEventPublisher (only applicable when running in an application context)
8. MessageSourceAware's setMessageSource (only applicable when running in an application context)
9. ApplicationContextAware's setApplicationContext (only applicable when running in an application context)
10. ServletContextAware's setServletContext (only applicable when running in a web application context)
11. postProcessBeforeInitialization methods of BeanPostProcessors
12. InitializingBean's afterPropertiesSet
13. a custom init-method definition
14. postProcessAfterInitialization methods of BeanPostProcessors

shutdown methods:
1. postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors
2. DisposableBean's destroy
3. a custom destroy-method definition

### HierarchicalBeanFactory

BeanFactory 的子接口，是可以成为 hierarchy 的一部分。可以在 
ConfigurableBeanFactory 接口中找到 setParentBeanFactory 方法，该方法允许以可配置
的方式设置 parent。

### ListableBeanFactory

ListableBeanFactory 可以列举出所有 bean 实例，而不是根据客户端的请求逐个尝试按名称查找
bean。预加载所有 bean definitions 的 BeanFactory 实现(如，基于 XML 的 BeanFactory)，
可以实现这个接口。

如果当前 BeanFactory 是 HierarchicalBeanFactory，则返回值将不考虑任何 BeanFactory 层次结构，
而仅与当前 BeanFactory 中定义的 bean 有关。使用 BeanFactoryUtils 帮助类去考虑 ancestor Factory
中的 bean。

该接口中的方法将仅遵守当前 BeanFactory 中的 bean definitions。它们将忽略任何通过其它手段注册的 
singleton beans，如 ConfigurableBeanFactory's registerSingleton 方法；但是
getBeanNamesForType and getBeansOfType 会检查手动注册的 singleton beans。当然，
BeanFactory#getBean 方法确实也允许透明访问此类的特殊 Bean。但是，在典型情况下，无论如何，
所有 bean 都将由外部 bean definitions 来定义，因此大多数应用程序不必担心这种区别。

注意: 除了 getBeanDefinitionCount 和 containsBeanDefinition 之外，此接口中的方法并非设计
用于频繁调用。实施可能很慢。

### AutowireCapableBeanFactory

具有 autowiring 能力的 BeanFactory，前提是它们希望为现有 bean 实例公开此功能。 

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。

其他框架的集成代码可以利用此接口来 wire 和 populate Spring 无法控制生命周期的现有 bean 实例。
例如: WebWork Actions and Tapestry Page objects。

请注意，此接口不是由 ApplicationContext facades 实现的，因为应用程序代码几乎从未使用过此接口。
也就是说，它也可以从 application context 中获得，可以通过 
ApplicationContext#getAutowireCapableBeanFactory 方法进行访问。

您还可以实现 BeanFactoryAware 接口，该接口即使在 ApplicationContext 中运行时也公开内部 
BeanFactory，以访问 AutowireCapableBeanFactory: 只需将传入的 BeanFactory 强制转换为 
AutowireCapableBeanFactory。

### AliasRegistry

别名注册表，用于管理别名的公共接口；作为`BeanDefinitionRegistry`的父接口。

### BeanDefinitionRegistry

`BeanDefinition`注册表，用于注册诸如`RootBeanDefinition`和`ChildBeanDefinition`之类的实例。
通常由内部使用AbstractBeanDefinition层次结构的BeanFactory实现。

这仅仅是一个 Spring's bean factory 包中的接口，用于封装`BeanDefinition`的注册。
标准BeanFactory接口仅覆盖对完全配置的工厂实例的访问。

Spring's BeanDefinition 的读取者希望能够处理这个接口的实现。
Spring 核心中已知的实现者是 DefaultListableBeanFactory 和 GenericApplicationContext。

### SingletonBeanRegistry

为共享 bean 实例定义注册表的接口。以统一的方式公开它们的单例管理工具。ConfigurableBeanFactory 
实现了此接口。

### ConfigurableBeanFactory

可配置的 BeanFactory 接口。

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。此扩展接口仅用于允许在框架内部进行即插即用，并允许对 BeanFactory 配置方法的
特殊访问。

### ConfigurableListableBeanFactory

提供了用于分析和修改 bean definitions 以及 pre-instantiate 单例的工具。

当前接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用 BeanFactory 或 
ListableBeanFactory。此扩展接口仅用于允许在框架内部进行即插即用，并允许对 BeanFactory 配置方法的
特殊访问。

### SimpleAliasRegistry

AliasRegistry 的简单实现。

* Map\<String, String\> aliasMap: alias --\> beanName

### DefaultSingletonBeanRegistry

共享 bean 实例的泛化注册表。允许注册 singleton 实例，该注册表的所有调用者都能通过 bean name 获取
共享 bean 实例。

支持 DisposableBean 实例注册。在注册表关闭时，执行 destroy 方法。可以注册 Bean 之间的依赖关系以
强制执行适当的关闭顺序。

此类主要用作 BeanFactory 实现的基类，从而排除了 singleton bean 实例的常见管理。

请注意，与 AbstractBeanFactory 和 DefaultListableBeanFactory 相比，此类既不假定 
bean definition 概念也不为 bean 实例指定创建过程。也可以用作委托的嵌套帮助器。

* Map\<String, Object\> singletonObjects: beanName --\> singleton bean instance
* Map\<String, ObjectFactory\<?\>\> singletonFactories: beanName --\> singleton ObjectFactory instance
* Map\<String, Object\> earlySingletonObjects: bean name --\> singletonFactories's ObjectFactory.getObject
* Set\<String\> registeredSingletons: 已经注册的 singletonObjects 和 singletonFactories 的 beanName
* Set\<String\> singletonsCurrentlyInCreation: 当前正在创建的 singleton bean instance 的 beanName
* Set\<String\> inCreationCheckExclusions: 校验是否是正在创建的 singleton bean instance 时需要排除的 beanName
* Set\<Exception\> suppressedExceptions: 抑制的异常，默认个数为 100 个(SUPPRESSED_EXCEPTIONS_LIMIT)
* boolean singletonsCurrentlyInDestruction: 指示我们当前是否在destroySingletons中的标志。
* Map\<String, Object\> disposableBeans: beanName --\> disposable bean instance
* Map\<String, Set\<String\>\> containedBeanMap: beanName --\> 其包含的 bean 的 beanName
* Map\<String, Set\<String\>\> dependentBeanMap: beanName --\> 依赖其的 bean 的 beanName
* Map\<String, Set\<String\>\> dependenciesForBeanMap: beanName --\> 其依赖的 bean 的 beanName

### FactoryBeanRegistrySupport

支持 FactoryBean 实例的注册。

* Map\<String, Object\> factoryBeanObjectCache: FactoryBean name --\> FactoryBean.getObject

### AbstractBeanFactory

BeanFactory 的抽象基类，提供了 ConfigurableBeanFactory SPI 的完整能力。不假定可列出的bean工厂: 
因此也可以用作 BeanFactory 实现的基类，该实现从某些后端资源获取 bean definitions。(其中 
bean definitions 访问是一项昂贵的操作)。

该类提供一个 singleton 缓存，通过它的的基类 DefaultSingletonBeanRegistry，singleton/prototype 判定，
FactoryBean 处理，别名，bean definition 合并 child bean definitions，bean 销毁(DisposableBean, 
自定义 destroy 方法)。此外，它可以通过实现 HierarchicalBeanFactory 管理 BeanFactory 的 hierarchy 结构，
在未知 bean 的情况下委托给 parent BeanFactory。

子类实现的主要模板方法: getBeanDefinition(String) 和 createBean(String, RootBeanDefinition, Object[])，
使用给定的 beanName 检索 bean definition。默认实现在 DefaultListableBeanFactory 和 
AbstractAutowireCapableBeanFactory 中。

* BeanFactory parentBeanFactory: parent BeanFactory
* ClassLoader beanClassLoader: 解析 bean class name 使用的 ClassLoader
* ClassLoader tempClassLoader: 临时解析 bean class name 使用的 ClassLoader，一般在 load-time weaver 模式下使用
* boolean cacheBeanMetadata: 是否缓存 Bean 元数据还是在每次访问时重新获取它
* BeanExpressionResolver beanExpressionResolver: bean definition values 中的表达式解析策略
* ConversionService conversionService: Spring 用于取代 PropertyEditors 的 ConversionService
* Set\<PropertyEditorRegistrar\> propertyEditorRegistrars: 自定义的 PropertyEditorRegistrars
* Map\<Class\<?\>, Class\<? extends PropertyEditor\>\> customEditors: requiredType --\> 自定义的 PropertyEditor 
* TypeConverter typeConverter: Spring 用于覆盖默认的 PropertyEditor 机制的 TypeConverter
* List\<StringValueResolver\> embeddedValueResolvers: String 解析器，如解析注解的属性值
* List\<BeanPostProcessor\> beanPostProcessors: BeanPostProcessors
* boolean hasInstantiationAwareBeanPostProcessors: 标记是否有 InstantiationAwareBeanPostProcessors 被注册
* boolean hasDestructionAwareBeanPostProcessors: 标记是否有 DestructionAwareBeanPostProcessors 被注册
* Map\<String, Scope\> scopes: scope 的标识 String --\> 相应的 Scope
* SecurityContextProvider securityContextProvider: 当在 SecurityManager 模式下运行时的 Security context
* Map\<String, RootBeanDefinition\> mergedBeanDefinitions: beanName --\> 合并后的 RootBeanDefinition
* Set\<String\> alreadyCreated: 至少创建过一次的 bean 的 beanName
* ThreadLocal\<Object\> prototypesCurrentlyInCreation: 当前正在创建的 prototype bean

### AbstractAutowireCapableBeanFactory

实现默认 bean 创建的抽象 BeanFactory 父类，具有 RootBeanDefinition 类指定的全部功能。

提供 bean 创建(构造器解析)，属性填充，连接(包括自动连接)，初始化。处理运行时 Bean 引用，解析托管集合，
调用初始化方法等。支持通过 name 自动注入 constructors, properties，通过 type 自动注入 properties。

子类主要实现的模板方法是 resolveDependency(DependencyDescriptor, String, Set, TypeConverter)，
使用 type 自动注入。如果工厂能够搜索其 bean definitions，则通常将通过此类搜索来实现匹配的 bean。
对于其他工厂样式，可以实现简化的匹配算法。

请注意，此类不承担或实现 bean definition 注册表功能。有关 ListableBeanFactory 和 
BeanDefinitionRegistry 接口的实现，请参见 DefaultListableBeanFactory，它们分别表示该工厂的 
API 和 SPI 视图。

* InstantiationStrategy instantiationStrategy: 创建 bean 实例的策略
* ParameterNameDiscoverer parameterNameDiscoverer: 方法参数的名字的解析策略
* boolean allowCircularReferences: 是否在 bean 间自动尝试解析循环引用
* boolean allowRawInjectionDespiteWrapping: 在循环引用的情况下，是否求助于注入一个原始 bean 实例，即使注入的 bean 最终被包装了
* Set\<Class\<?\>\> ignoredDependencyTypes: 在依赖校验或自动注入时，忽略的 types
* Set\<Class\<?\>\> ignoredDependencyInterfaces: 在依赖校验或自动注入时，忽略的 interfaces
* NamedThreadLocal\<String\> currentlyCreatedBean: 当前正在创建的 bean 的 beanName，隐式的依赖登记从用户指定的 Supplier 的回调触发的 getBean 等调用的名称。
* ConcurrentMap\<String, BeanWrapper\> factoryBeanInstanceCache: FactoryBean name --\> BeanWrapper
* ConcurrentMap\<Class\<?\>, Method[]\> factoryMethodCandidateCache: factory class --\> candidate factory methods
* ConcurrentMap\<Class\<?\>, PropertyDescriptor[]\> filteredPropertyDescriptorsCache: bean Class --\> PropertyDescriptor array

### DefaultListableBeanFactory

一个基于 bean definition 元数据的成熟 BeanFactory，可以通过 post-processors 扩展。

典型的用法是在访问 bean 之前，注册所有的 bean definitions。因此，按名称查找 Bean 是在本地 bean definition 表中
进行的廉价操作，它对预解析的 bean definition 元数据对象进行操作。

注意，特定 bean definition 格式的阅读器通常是单独实现的，而不是作为 BeanFactory 的子类实现的：
例如，参见 XmlBeanDefinitionReader。

* Class\<?\> javaxInjectProviderClass: javax.inject.Provider or null
* Map\<String, Reference\<DefaultListableBeanFactory\>\> serializableFactories: serializationId --\> DefaultListableBeanFactory
* String serializationId: 用于序列化的 id
* boolean allowBeanDefinitionOverriding: 是否允许 bean definition 覆盖
* boolean allowEagerClassLoading: 是否允许早期类加载
* Comparator\<Object\> dependencyComparator: 依赖列表的比较器
* AutowireCandidateResolver autowireCandidateResolver: 用于检查 bean definition 是否为自动装配候选的 Resolver
* Map\<Class\<?\>, Object\> resolvableDependencies: dependency type --\> 自动注入值
* Map\<String, BeanDefinition\> beanDefinitionMap: beanName --\> bean definition
* Map\<String, BeanDefinitionHolder\> mergedBeanDefinitionHolders: beanName --\> 已合并的 BeanDefinitionHolder
* Map\<Class\<?\>, String[]\> allBeanNamesByType: dependency type --\> singleton and non-singleton bean names
* List\<String\> beanDefinitionNames: bean definition names
* Set\<String\> manualSingletonNames: 手动注册的 singletons 的 names
* String[] frozenBeanDefinitionNames: 冻结配置之后的 bean definition names
* boolean configurationFrozen: bean definition 元数据是否已经被冻结






















