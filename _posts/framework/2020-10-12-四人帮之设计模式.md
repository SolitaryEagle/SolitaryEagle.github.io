---
layout:     post
title:      四人帮之设计模式
subtitle:   四人帮之设计模式
date:       2020-10-12
author:     Eagle Cool
header-img: img/post-bg-ios9-web.jpg
catalog: 	true
tags:       framework
---

> * [代理模式 vs 装饰器模式](http://www.jasongj.com/design_pattern/proxy_decorator/)
> * [代理模式 vs 中介者模式 vs 外观模式](https://blog.csdn.net/mengmei16/article/details/43981791)
> * [备忘录模式 vs 命令模式](https://blog.csdn.net/luckystar689/article/details/42125073)

# 设计模式记忆

* 创建型: 抽工生原单
* 结构型: 适桥组装外享代
* 行为型: 责命解迭中，备观状策模访

# 创建型

## 抽象工厂

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

![0WiZIU.png](https://s1.ax1x.com/2020/10/12/0WiZIU.png)

* 分离了具体的类
* 使得易于交换产品系列
* 有利于产品的一致性
* 难以支持新种类的产品(每个具体工厂都得添加生产产品的方法)

## 工厂方法

定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到子类

![0WkMHx.png](https://s1.ax1x.com/2020/10/12/0WkMHx.png)

* 不再将与特定应用有关的类绑定到你的代码中
* 仅仅为了创建一个特定的 Product 对象，就不得不创建 Creator 的子类
* 为子类提供挂钩
* 连接平行的类层次

## 生成器

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

![0WFRAK.png](https://s1.ax1x.com/2020/10/12/0WFRAK.png)

* 使你可以改变一个产品的内部表示
* 将构造代码和表示代码分开
* 使你可对构造过程进行更精细的控制

## 原型

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

![0WAnJS.png](https://s1.ax1x.com/2020/10/12/0WAnJS.png)

* 运行时刻增加和删除产品
* 改变值以指定新对象
* 改变结构以指定新对象
* 减少子类的构造
* 用类动态配置应用

## 单例

保证一个类仅有一个实例，并且提供一个访问它的全局访问点。

![0WAyo6.png](https://s1.ax1x.com/2020/10/12/0WAyo6.png)

* 对唯一实例的受控访问
* 缩小名空间
* 允许对操作和表示的精化
* 允许可变数目的实例
* 比类操作更灵活

# 结构型

## 适配器

将一个类的接口转换成客户希望的另外一个接口。

![0fnn9x.png](https://s1.ax1x.com/2020/10/13/0fnn9x.png)

类适配器:
* 无法匹配一个类及其所有子类
* 可以重定义 Adaptee 的部分行为
* 仅仅引入一个对象，并不需要额外的指针以间接得到 Adaptee

对象适配器:
* 允许一个 Adapter 与多个 Adaptee 同时工作
* 重定义 Adaptee 的行为比较困难

注意点:
* Adapter 的匹配程度
* 可插入的 Adapter
* 使用双向适配器提供透明操作

## 桥接

将抽象部分与它的实现部分分离，使它们都可以独立的变化。

![0fQsyV.png](https://s1.ax1x.com/2020/10/13/0fQsyV.png)

* 分离接口及其实现部分
* 提高可扩充性
* 实现细节对客户透明

## 组合

将对象组合成树形结构以表示 "部分-整体" 的层次结构。
使得用户对单个对象和组合对象的使用具有一致性。

![0flT9s.png](https://s1.ax1x.com/2020/10/13/0flT9s.png)

* 定义了包含基本对象和组合对象的类层次结构
* 简化客户代码
* 使得更容易增加新类型的组件
* 使你的设计更加一般化

## 装饰

动态地给一个对象添加一些额外的职责。

![0f1654.png](https://s1.ax1x.com/2020/10/13/0f1654.png)

* 比静态继承更灵活
* 避免在层次结构高层的类有太多的特征
* 有许多小对象

## 外观

为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，
这个接口使得子系统更加容易使用。

![0f3OkF.png](https://s1.ax1x.com/2020/10/13/0f3OkF.png)

* 对客户屏蔽子系统组件
* 实现了子系统与客户之间的松耦合关系
* 并不限制使用子系统的类

## 享元

运用共享技术有效地支持大量细粒度的对象。

![0f8Ate.png](https://s1.ax1x.com/2020/10/13/0f8Ate.png)
![0f8nXt.png](https://s1.ax1x.com/2020/10/13/0f8nXt.png)

* 节省存储空间
* 传输、查找、计算外部状态都会产生运行时的开销
* 用共享减少内部状态的消耗，用计算时间换取对外部状态的存储

## 代理

为其它对象提供一种代理以控制对这个对象的访问。

![0fJndf.png](https://s1.ax1x.com/2020/10/13/0fJndf.png)
![0fJMFS.png](https://s1.ax1x.com/2020/10/13/0fJMFS.png)

* Remote Proxy 可以隐藏一个对象存在于不同地址空间的事实
* Virtual Proxy 可以进行最优化
* Protection Proxies 和 Smart Reference 都允许在访问一个对象时有一些附加的内务处理
* 可以对用户隐藏一种称之为 copy-on-write 的优化方式，只有在真正修改被代理的对象时才进行拷贝

# 行为型

## 责任链

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合性。
将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

![0fIh4K.png](https://s1.ax1x.com/2020/10/13/0fIh4K.png)

* 降低耦合度
* 增强了给对象指派职责的灵活性
* 不保证被接受

## 命令

将一个请求封装成为一个对象，从而使你可以使用不同的请求对客户进行参数化；
对请求排队或记录请求日志，以及支持可撤销的操作。

![0fonv4.png](https://s1.ax1x.com/2020/10/13/0fonv4.png)

* 将调用操作的对象与知道如何实现该操作的对象解耦
* 可以像其它对象一样被操纵和扩展
* 可以将多个命令组合成一个复合命令
* 增加新的 Command 很容易

## 解释器

给定一个语言，定义它的文法的一种表示，并定义一个解析器，这个解释器使用该表示来解释语言中的句子。

![0foTiV.png](https://s1.ax1x.com/2020/10/13/0foTiV.png)

* 易于改变和扩展文法
* 易于实现文法
* 复杂的文法难以维护
* 增加了新的解释表达式的方式

## 迭代器

提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

![0f7it0.png](https://s1.ax1x.com/2020/10/13/0f7it0.png)

* 支持以不同的方式遍历一个聚合
* 迭代器简化了聚合的接口
* 在同一个聚合上可以有多个遍历

## 中介者

用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示地相互引用，
从而使其耦合松散，而且可以独立地改变它们之间的交互。

![0f7TvF.png](https://s1.ax1x.com/2020/10/13/0f7TvF.png)

* 减少子类的生成
* 将各 Colleague 解耦
* 简化了对象协议
* 对对象如何协作进行了抽象
* 使控制集中化

## 备忘录

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
这样以后就可将该对象恢复到原先保存的状态。

![0fHLQS.png](https://s1.ax1x.com/2020/10/13/0fHLQS.png)

* 保持封装边界
* 简化了原发器
* 可能代价很高
* 定义窄接口和宽接口
* 维护备忘录存在潜在代价

## 观察者

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

![0fbNFI.png](https://s1.ax1x.com/2020/10/13/0fbNFI.png)

* 目标与观察者间的抽象耦合
* 支持广播通信
* 意外的更新

## 状态

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

![0fqogf.png](https://s1.ax1x.com/2020/10/13/0fqogf.png)

* 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来
* 使得状态转换显示化
* State 对象可被共享

## 策略

定义一系列的算法，把它们一个个封装起来，并且使它们可以互相转换。
使算法可独立于使用它的客户而变化。

![0fLWsU.png](https://s1.ax1x.com/2020/10/13/0fLWsU.png)

* 相关算法系列
* 一个替代继承的方法
* 消除了一些条件语句
* 实现的选择
* 客户必须了解不同的的 Strategy
* Strategy 和 Context 之间的通信开销
* 增加了对象的数目

## 模板方法

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。

![0fOwSx.png](https://s1.ax1x.com/2020/10/13/0fOwSx.png)

* 具体的操作
* 具体的 AbstractClass 的操作
* 原语操作
* Factory Method
* 钩子操作

## 访问者

表示一个作用于某对象结构中的各个元素的操作。
它使你可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。

![0fjKMV.png](https://s1.ax1x.com/2020/10/13/0fjKMV.png)

* 易于增加新的操作
* 集中相关的操作而分离无关的操作
* 增加新的 ConcreteElement 类很困难
* 通过类层次进行访问
* 累积状态
* 破坏封装
