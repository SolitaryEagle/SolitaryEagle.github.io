---
layout:     post
title:      JDK java.util.concurrent 包
subtitle:   JDK 源码
date:       2020-11-11
author:     Eagle Cool
header-img: img/post-bg-ios9-web.jpg
catalog: 	true
tags:       JDK
---

# Lock

* void lock(): 获取锁
* void lockInterruptibly(): 获取锁，除非当前线程被中断
* boolean tryLock(): 获取锁，如果获取到返回 true，否则返回 false
* boolean tryLock(long time, TimeUnit unit): 如果在指定的时间内获取到锁，返回 true，否则返回 false
* void unlock(): 释放锁
* Condition newCondition(): 创建一个条件，用于线程通信

# Condition

* void await(): 休眠线程
* void awaitUninterruptibly(): 不可中断休眠
* long awaitNanos(long nanosTimeout): 休眠指定时间
* boolean await(long time, TimeUnit unit): ==> awaitNanos(unit.toNanos(time)) > 0
* boolean awaitUntil(Date deadline): 休眠直到指定的时间
* void signal(): 唤醒当前 Condition 的一个线程
* void signalAll(): 唤醒当前 Condition 的所有线程

# LockSupport

不会释放持有的锁

* static Object getBlocker(Thread t): 获取 Thread 的 parkBlocker 字段
* static void park(): 如果获取不到许可证，则休眠当前线程
* static void park(Object blocker): 如果获取不到许可证，休眠当前线程，并设置 Thread 的 parkBlocker 字段
* static void parkNanos(long nanos): 如果获取不到许可证，休眠指定的时间
* static void parkNanos(Object blocker, long nanos): 如果获取不到许可证，休眠指定的时间
* static void parkUntil(long deadline): 如果获取不到许可证，休眠直到指定的时间
* static void parkUntil(Object blocker, long deadline): 如果获取不到许可证，休眠直到指定的时间
* static void unpark(Thread thread): 发放许可证

# AbstractOwnableSynchronizer

* transient Thread exclusiveOwnerThread: 独占模式同步的当前所有者。

# AbstractQueuedSynchronizer

state 的值:
* 0: 表示锁未被获取
* 1: 表示锁被使用

监控功能
* final int getQueueLength(): 估计竞争中等待当前锁的线程数
* final int getWaitQueueLength(ConditionObject condition): 估计与当前条件相关的等待的线程数
* final boolean hasWaiters(ConditionObject condition): 判断是否有给定的 Condition await 的线程
* final boolean owns(ConditionObject condition): 判断当前同步器是否为给定条件的锁
* final boolean isQueued(Thread thread): 判断当前线程是否在当前同步器的竞争队列中
* final boolean compareAndSetState(int expect, int update): 将 state 的值通过 cas 操作从 0 变成 1


* final void acquire(int arg): 互斥模式下获取锁
* Node addWaiter(Node mode): 将当前线程加入 BLOCKED 队列，mode 表示互斥(Node.EXCLUSIVE)或共享(Node.SHARED)
    * 使用 mode 和 当前线程 创建一个 Node
    * 尝试直接将 Node 加入 BLOCKED 队列尾部
    * 如果失败，表示当前 BLOCKED 队列为空，创建一个队列后，将 Node 加入 BLOCKED 队列尾部
* final boolean acquireQueued(final Node node, int arg)
    * node 在 BLOCKED 队列中一直等待，直到位于队列的头节点，然后通过 tryAcquire(arg) 获取锁
    * 在 node 到达 BLOCKED 队列的头节点之前，判断当前线程是否应该 park 并通过 parkAndCheckInterrupt() 执行 park
    * 如果在上面嗯过程中发生了异常，并且未获取到锁，通过 cancelAcquire(node) 将 node 从 BLOCKED 队列中删除
* static boolean shouldParkAfterFailedAcquire(Node pred, Node node)
    * 如果 pred.waitStatus 等于 Node.SIGNAL，那么当前 node 应该 park
    * 如果 pred.waitStatus 大于 0，表示前一个节点被 cancel，则将当前 node 的所有被 cancel 的前节点都删除
    * 如果 pred.waitStatus 小于等于 0，则将通过 CAS 操作将 pred.waitStatus 设置为 Node.SIGNAL；下一次进来的时候就会返回 true
* final boolean parkAndCheckInterrupt(): park 当前线程，返回并清除线程的中断状态
* void cancelAcquire(Node node): 取消正在获取锁的线程的获取操作
    * 将 node 的 thread 引用置 null
    * 将 node 的 prev 指针指向前面最近的一个 waitStatus <= 0 的节点
    * 将 node 的 waitStatus 置为 Node.CANCELLED
    * 如果 node 为 tail 节点，通过 CAS 操作将前面最近那个 waitStatus <= 0 的节点设置为 tail 节点，并将其 next 指针置 null
    * 如果 node 不是 tail 节点
        * 如果前面最近那个 waitStatus <= 0 的节点是 head 节点，通过 unparkSuccessor(Node node) unpack 当前 node 的线程
        * 否则，前面最近那个 waitStatus <= 0 的节点是 head 节点的 waitStatus 为 Node.SIGNAL 并且其持有的 thread 不为 null，将其 next 指针指向 node 的下一个节点
        * 将 node 的 next 指针指向自己，help GC
* void unparkSuccessor(Node node)
    * TODO
    
## AbstractQueuedSynchronizer#ConditionObject

* final boolean isOwnedBy(AbstractQueuedSynchronizer sync): 判断当前 ConditionObject 实例是否是给定 sync 创建的
* final int getWaitQueueLength(): 估计与当前 ConditionObject 实例相关的等待的线程数
* final boolean hasWaiters(): 判断是否有给定的 Condition await 的线程


# ReentrantLock

监控功能
* final int getQueueLength(): 估计竞争中等待当前锁的线程数
* int getWaitQueueLength(Condition condition): 估计与当前条件相关的等待的线程数
* final boolean hasQueuedThread(Thread thread): 判断给定线程是否正在竞争当前锁
* final boolean hasQueuedThreads(): 判断是否有线程正在等待这个锁
* boolean hasWaiters(Condition condition): 判断是否有给定的 Condition await 的线程
* final boolean isFair(): 判断是否为公平锁
* boolean isHeldByCurrentThread(): 判断当前锁是否是被当前线程持有
* boolean isLocked(): 判断当前锁是否被任意线程持有


* int getHoldCount(): 查询当前线程对该锁的保持次数。
* void lock(): 加锁


## ReentrantLock#Sync

* boolean nonfairTryAcquire(int acquires)
    * 如果当前 state 的值为 0, 通过 cas 操作将 state 的值设置为 acquires，当前线程首次获取到锁
    * 如果锁的持有者是当前线程，将 state 的值加上 acquires，当前线程重入该锁




# ReadWriteLock

虽然读写锁的基本操作是直接的，但是实现必须做出许多策略决策，
这可能会影响给定应用程序中读写锁的有效性。

* 当读锁和写锁都在等待时，在写锁释放时，确定是授予读锁还是写锁。写锁偏好是常见的，
因为写操作被认为是短而不频繁的。读者偏好不太常见，因为如果读操作如预期的那样频繁且寿命长，
那么它会导致写操作的长时间延迟。公平或“有序”的实现也是可能的。
* 确定在读锁处于活动状态且写锁正在等待时，读操作请求读锁是否被授予。
对读锁的偏好可能会无限期地延迟写锁，而对写锁的偏好则会降低并发的性能。
* 确定锁是否可重入
* 是否可以将写锁降级为读锁而不允许中间写入程序？是否可以将读锁升级为写锁，而不是其他等待的读锁或写锁？

# ReentrantReadWriteLock





# ????

为什么 tryLock 不支持公平锁

