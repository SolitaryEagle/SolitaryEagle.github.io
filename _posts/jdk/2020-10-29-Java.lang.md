---
layout:     post
title:      JDK java.lang 包
subtitle:   JDK 源码
date:       2020-10-29
author:     Eagle Cool
header-img: img/post-bg-ios9-web.jpg
catalog: 	true
tags:       JDK
---

# Object

* String toString(): 返回 对象的类名@hashCode的无符号16进制表示
* native int hashCode()
    * 程序的一次执行期间，同一对象的多次调用，必须返回同一 int 值；程序在多次执行期间，不同次的程序执行期间，同一对象的调用，可以返回不一样的 int 值
    * 如果通过 equals(Object) 方法判断两个对象是相同的，那么两个对象的 hashCode 也必须一样
    * 虽然通过 equals(Object) 方法判断两个对象是不相同的，但是两个对象的 hashCode 也可以一样；然而，应该意识到不同对象的 hashCode 不一样可以提高对象在哈希表中的使用性能
* boolean equals(Object obj)
    * 自反性: x.equals(x) = true
    * 对称性: x.equals(y) = y.equals(x)
    * 传递性: x.equals(y) && y.equals(z) ==> x.equals(z)
    * 一致性: x.equals(y) 多次执行的结果都应该是一样的（比较的信息没有被改变）
    * null 性: x.equals(null) = false
* final native void wait(long timeout)
    * 当前对象必须是 monitor 对象，才可以调用。
    * 当前线程会释放拥有的 monitor 对象，然后进入当前对象的等待集中，且被禁止调度；直到下列事件之一发生:
        * 其它线程调用了当前对象的 notify 方法，并且当前线程恰巧被唤醒
        * 其它线程调用了当前对象的 notifyAll 方法
        * 其它线程调用了当前线程的 interrupts 方法
        * timeout 不为 0, 且时间已到
    * 当前线程在获取到 monitor 对象之后，才有可能 throw InterruptedException
    * 当前线程只释放当前 monitor 对象（当前线程可能拥有多个 monitor 对象）
* final void wait() ==》wait(0)
* final void wait(long timeout, int nanos) ==》wait(timeout[+1])
* final native void notify()
    * 当前对象必须是 monitor 对象，才可以调用。
    * 唤醒当前 monitor 对象的等待集中的任意一个线程。
    * 线程可以通过下列方式获取 monitor 对象:
        * 执行 synchronized 方法: monitor 为当前对象
        * 执行 synchronized 代码块: monitor 为指定对象
        * 执行 synchronized static 方法: monitor 为对应的 Class 对象
* final native void notifyAll()
    * 当前对象必须是 monitor 对象，才可以调用。
    * 唤醒当前 monitor 对象的等待集中的所有线程。
* final native Class<?> getClass(): 获取当前对象的 Class 对象
* native Object clone(): 执行浅拷贝, 子类需 implements Cloneable, 并覆盖此方法
* void finalize(): 对象回收之前会调用一次，在一个对象的生命周期中只会调用一次

# Appendable

* Appendable append(char c)
* Appendable append(CharSequence csq)
* Appendable append(CharSequence csq, int start, int end)

# CharSequence

* char charAt(int index)
* default IntStream chars()
* default IntStream codePoints()
* int length()
* CharSequence subSequence(int start, int end)
* String toString()


# Thread

当前线程: 正在执行的线程
被调用线程: 当前线程执行 thread.method() 中的 thread

调试用途的方法

* static native void yield(): 当前线程让出 CPU 权限
* static int activeCount(): 获取当前线程所在的线程组的线程存活数
* static int enumerate(Thread tarray[]): 将当前线程所在的线程组内的所有线程浅拷贝到 tarray 中
* static void dumpStack(): 打印当前线程的堆栈信息

常用方法

* static native Thread currentThread(): 获取当前线程
* synchronized void start(): 开始执行被调用线程
* static native void sleep(long millis): 当前线程暂停 millis
* static void sleep(long millis, int nanos) ==》sleep(millis[+1]) 当前线程暂停 millis[+1]
* final synchronized void join(long millis): 被调用的线程优先执行 millis
* final void join() ==》join(0): 被调用的线程一直优先执行
* final synchronized void join(long millis, int nanos) ==》join(millis[+1]): 被调用的线程优先执行 millis[+1]
* final native boolean isAlive(): 判断当前线程是否存活
* void run(): 线程执行体

稍常用方法

* long getId()
* final String getName()
* final synchronized void setName(String name)
* final int getPriority()
* final void setPriority(int newPriority)
* final boolean isDaemon()
* final void setDaemon(boolean on)
* static native boolean holdsLock(Object obj): 判断当前线程是否持有 obj monitor
* State getState()
* ClassLoader getContextClassLoader()
* void setContextClassLoader(ClassLoader cl)

不常用方法

* static Map<Thread, StackTraceElement[]> getAllStackTraces(): 获取所有线程的堆栈信息
* StackTraceElement[] getStackTrace(): 获取被调用线程的堆栈信息
* static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()
* static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)
* UncaughtExceptionHandler getUncaughtExceptionHandler()
* void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)
* static boolean interrupted(): 判断当前线程是否被中断，并清除中断状态
* void interrupt(): 中断被调用线程
* boolean isInterrupted(): 判断被调用线程是否被中断，但不清除中断状态
* final ThreadGroup getThreadGroup()



