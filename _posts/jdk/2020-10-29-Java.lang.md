---
layout:     post
title:      JDK java.lang 包
subtitle:   JDK 源码
date:       2020-10-29
author:     Eagle Cool
header-img: img/post-bg-ios9-web.jpg
catalog: 	true
tags:       JDK
---

# Appendable

* Appendable append(char c)
* Appendable append(CharSequence csq)
* Appendable append(CharSequence csq, int start, int end)

# CharSequence

* char charAt(int index)
* default IntStream chars()
* default IntStream codePoints()
* int length()
* CharSequence subSequence(int start, int end)
* String toString()


# Thread

当前线程: 正在执行的线程
被调用线程: 当前线程执行 thread.method() 中的 thread

调试用途的方法

* static native void yield(): 当前线程让出 CPU 权限
* static int activeCount(): 获取当前线程所在的线程组的线程存活数
* static int enumerate(Thread tarray[]): 将当前线程所在的线程组内的所有线程浅拷贝到 tarray 中
* static void dumpStack(): 打印当前线程的堆栈信息

常用方法

* static native Thread currentThread(): 获取当前线程
* synchronized void start(): 开始执行被调用线程
* static native void sleep(long millis): 当前线程暂停 millis
* static void sleep(long millis, int nanos) ==》sleep(long millis) 当前线程暂停 millis[+1]
* final void join() ==》join(long millis): 被调用的线程一直优先执行
* final synchronized void join(long millis): 被调用的线程优先执行 millis
* final synchronized void join(long millis, int nanos): 被调用的线程优先执行 millis[+1]
* final native boolean isAlive(): 判断当前线程是否存活
* void run(): 线程执行体

稍常用方法

* long getId()
* final String getName()
* final synchronized void setName(String name)
* final int getPriority()
* final void setPriority(int newPriority)
* final boolean isDaemon()
* final void setDaemon(boolean on)
* static native boolean holdsLock(Object obj): 判断当前线程是否持有 obj monitor
* State getState()
* ClassLoader getContextClassLoader()
* void setContextClassLoader(ClassLoader cl)

不常用方法

* static Map<Thread, StackTraceElement[]> getAllStackTraces(): 获取所有线程的堆栈信息
* StackTraceElement[] getStackTrace(): 获取被调用线程的堆栈信息
* static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()
* static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)
* UncaughtExceptionHandler getUncaughtExceptionHandler()
* void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)
* static boolean interrupted(): 判断当前线程是否被中断，并清除中断状态
* void interrupt(): 中断被调用线程
* boolean isInterrupted(): 判断被调用线程是否被中断，但不清除中断状态
* final ThreadGroup getThreadGroup()



